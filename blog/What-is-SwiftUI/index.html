<!DOCTYPE html><html lang="en"><head><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet"/><script src="https://kit.fontawesome.com/662f6d0c39.js" crossorigin="anonymous"></script><script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/></head><head><meta charset="UTF-8"/><meta name="og:site_name" content="Jihoonahn Blog"/><link rel="canonical" href="https://blog.jihoon.me/blog/What-is-SwiftUI"/><meta name="twitter:url" content="https://blog.jihoon.me/blog/What-is-SwiftUI"/><meta name="og:url" content="https://blog.jihoon.me/blog/What-is-SwiftUI"/><title>SwiftUI 소개 | Jihoonahn Blog</title><meta name="twitter:title" content="SwiftUI 소개 | Jihoonahn Blog"/><meta name="og:title" content="SwiftUI 소개 | Jihoonahn Blog"/><meta name="description" content="선언형 UI로 생산성을 높여주는 SwiftUI에 대한 설명입니다."/><meta name="twitter:description" content="선언형 UI로 생산성을 높여주는 SwiftUI에 대한 설명입니다."/><meta name="og:description" content="선언형 UI로 생산성을 높여주는 SwiftUI에 대한 설명입니다."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/static/styles/default_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/header_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/about_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/post_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/sectionPage_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/errorPage_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/footer_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/tag_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/tagDetail_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/pagination_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/nextAndPreview_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/docsearch_style.css" type="text/css"/><link rel="stylesheet" href="/static/styles/home_style.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Jihoonahn Blog"/></head><body><header id="blog-head" class="blog-head outer"><div class="blog-head-inner inner"><div class="blog-head-brand"><div class="menu-icon-container"><div class="menu-icon"><span class="line-1"></span><span class="line-2"></span></div></div><a href="/" class="blog-head-logo"><img src="/static/images/Icon/icon.svg" alt="Jihoonahn Blog"/></a><div class="DocSearch-Button-container"><div id="docsearch" class="blog-search blog-icon-btn"></div></div></div><nav class="blog-head-menu"><ul class="nav"><li><a href="/blog" class="nav-item">Blog</a></li><li><a href="/about" class="nav-item">About</a></li></ul></nav></div><script src="/static/scripts/Header/header-scroll.js"></script><script src="/static/scripts/Header/header-menu.js"></script><script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script><script type="text/javascript" src="/static/scripts/Doc_Search/DocSearch.js"></script></header><div class="wrapper"><article><header class="site-post-head"><div class="site-post-head-image" style="background-image: url(/static/images/Blog/blog/What-is-SwiftUI.svg)"></div></header><div class="site-post-head-title"><h1>SwiftUI 소개</h1><section class="site-post-full-meta"><time>2022.10.20</time><span class="date-divider">|</span><a href="https://blog.jihoon.me/tags/tutorial">Tutorial. </a><a href="https://blog.jihoon.me/tags/swiftui">SwiftUI. </a><a href="https://blog.jihoon.me/tags/theory">Theory. </a></section></div><div class="site-post-body"><div><iframe width="100%" height= "400" src="https://www.youtube.com/embed/psL_5RIBqnY?start=7603" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p><strong>본 영상은 WWDC 19이며 SwiftUI 소개되는 부분에서 시작이됩니다.</strong></p><p>2019년 애플의 WWDC에서 처음 소개된 SwiftUI 는 모든 애플 운영체제용 앱을 개발하는데 있어서 완전히 새로운 방법을 제공합니다.</p><p>SwiftUI의 기본적인 목적은 앱 개발을 더 쉽고 폭발적인 생산성을 내면서 동시에 소프트웨어를 개발할 때 일반적으로 발생하는 버그들을 줄이는 것입니다. <br/> 또한 개발 과정에서도 앱의 라이브 프리뷰 기능을 이용하여 SwiftUI 프로젝트를 실시간으로 테스트할 수 있게 합니다. <br/></p><img width="100%" src="https://user-images.githubusercontent.com/68891494/229286766-44425ba2-bc64-4955-b106-99d99904313f.png"></img><p>위 이미지는 SwiftUI Project를 생성했을 때의 모습입니다. <br/><br/></p><h2>SwiftUI의 선언적 구문</h2><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Hello, world!"</span>)
                .<span class="call">frame</span>(maxWidth: .<span class="dotAccess">infinity</span>, maxHeight: .<span class="dotAccess">infinity</span>)
                .<span class="call">foregroundColor</span>(.<span class="dotAccess">white</span>)
        }
        .<span class="call">padding</span>()
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>UIKit과 인터페이스 빌더를 User Interface Layout을 설계하고 필요한 동작을 구현하는 것과는 완전히 다른 방법인 선언적 구문(declairactive syntax)이 SwiftUI에 도입되었습니다. <br/> 이 과정에서 기본적으로 레이아웃에 포함될 컴포넌트들을 선언하고, 그것들이 포함될 레이아웃 메니지 종류 (VStack, HStack, Form, List 등)를 명시하고, 속성을 설정하기 위해 수정자(modifier)를 사용합니다. <br/> 이렇게 선언하고 난 후 레이아웃의 위치와 constraint그리고 렌더링 방법에 대한 모든 복잡한 세부 사항은 SwiftUI가 자동으로 처리합니다. <br/> SwiftUI 선언은 계층적으로 구조화 되어 있습니다. 따라서 복잡한 뷰를 보다 쉽게 생성할 수 있습니다. <br/> <br/></p><h2>SwiftUI는 데이터 주도적</h2><p>SwiftUI 이전에는 앱 내에 있는 데이터의 현재 값을 검사하려면 그에 대한 코드를 앱에 포함 해야했습니다. <br/> 시간에 지남에 따라 데이터가 변한다면 사용자 인터페이스가 데이터의 최신 상태를 항상 반영하도록 하는 코드를 작성하거나, 데이터가 변경되었는지 주기적으로 검사하는 코드를 작성하는 것, 그리고 갱신 메뉴를 제공 해야했습니다. <br/> 이러한 데이터 소스를 앱의 여러 영역에서 사용할 경우 소스 코드의 복잡도가 증가합니다. <br/></p><blockquote><p><strong>SwiftUI는 앱의 데이터 모델과 사용자 인터페이스 컴포넌트, 그리고 기능을 제공하는 로직을 binding하는 여러방법으로 복잡도를 해결하게 됩니다.</strong> <br/></p></blockquote><p>데이터 주도로 구현하면 데이터 모델은 앱의 다른 부분에서 subscibe 할 수 데이터 변수는 publish 하게 됩니다. (publisher – subsciber) <br/> 이러한 방법을 통해 데이터가 변경되었다는 사실을 모든 구독자에게 자동으로 알릴 수 있습니다.<br/> 만약 사용자 인터페이스 컴포넌트와 데이터 모델 간에 바인딩이 된다면, <strong>추가적인 코드를 작성하지 않아도 모든 데이터의 변경 사항을 SwiftUI가 사용자 인터페이스에 자동으로 반영할 것</strong>입니다. <br/><br/></p><h2>UIKit VS SwiftUI</h2><img width="100%" src = "https://res.cloudinary.com/practicaldev/image/fetch/s--Ry1DiaP7--/c_imagga_scale,f_auto,fl_progressive,h_900,q_auto,w_1600/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85fmihrdl249k9cuid1i.png"></img><p><strong>UIKit</strong></p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
     
    <span class="keyword">private lazy var</span> button: <span class="type">UIButton</span> = {
        <span class="keyword">let</span> button = <span class="type">UIButton</span>()
        button.<span class="call">setTitle</span>(<span class="string">"Hello UIKit"</span>, for: .<span class="dotAccess">normal</span>)
        button.<span class="call">addTarget</span>(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(helloUIKitButtonAction), for: .<span class="dotAccess">touchUpInside</span>)
        <span class="keyword">return</span> button
    }()
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        view.<span class="property">backgroundColor</span> = .<span class="dotAccess">black</span>
        
        view.<span class="call">addSubview</span>(button)
        
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            button.<span class="property">centerXAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerXAnchor</span>),
            button.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerYAnchor</span>)
        ])
    }
    
    <span class="keyword">@objc private func</span> helloUIKitButtonAction() {
        <span class="call">printContent</span>(<span class="string">"Hello UIKit!"</span>)
    }
}
</code></pre><p><strong>SwiftUI</strong></p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Button</span>(<span class="string">"Hello SwiftUI"</span>) {
                <span class="call">print</span>(<span class="string">"Hello SwiftUI!"</span>)
            }
        }
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>같은 동작을 하는 뷰를 만들어 봤습니다. <br/></p><p>차이점이 보이시나요? UIKit(명령형)과 SwiftUI(선언형)을 비교해볼 때 <br/></p><p>UIKit에서는 Property를 선언 view에 추가하고, Layout에 제약사항을 준 후, action을 할 함수를 만들어서 button에 addTarget 해줍니다. <br/></p><p>하지만 SwiftUI에서는 그래로 원하는 위치에 Button을 추가하고 action을 추가하면 끝납니다. <br/></p><p>생산성 부분에서 어마어마하게 차이가 난다는 걸 볼 수 있습니다. <br/><br/></p><h2>UIKit과 SwiftUI를 함께 사용하는 방법</h2><p>사실 UIView와 SwiftUI를 함께 사용할 수 있는 방법은 다양하게 존재합니다. <br/></p><p>SwiftUI는 빠르고 효율적인 앱 개발 환경을 제공할 뿐만 아니라 코드를 크게 변경하지 않아도 다양한 애플 플랫폼에서 동일한 앱을 사용할 수 있게 합니다.<br/></p><p>하지만 지도 또는 웹 뷰를 통합해야 하는 특정 기능은 여전히 UIKit을 사용해야 하고, 매우 복잡한 UI 레이아웃을 설계하는 경우에 SwiftUI 레이아웃 컨테이너 뷰 사용이 만족스럽지 않을 수 있습니다. <br/></p><p>이런 상황에서는 인터페이스 빌더를 사용을 하는 방식으로 해결할 수도 있습니다. <br/><br/></p><h2>지금 SwiftUI는 어떨까?</h2><p>현재까지는 시기상조라는 말도 있고, 회사에서 도입 할 것이라는 말이 있습니다. <br/> 이 부분은 사람마다 의견이 다르기 때문에 정확한 대답은 어렵지만, 개인적으로 저는 자신이 처한 상황에서 직접 고려하여 결정하는 것이 좋다고 생각합니다. <br/></p><p>SwiftUI 최소 버전은 iOS 기준 13.0이지만, 제대로 사용하려면 15.0 이상이여야 하기 때문에, 이러한 부분은 좀 많이 아쉽긴 합니다. <br/></p><p>그리고 현재 SwiftUI는 버그도 있기도 하고, 아직 사용하기에는 불완전하다는 말에 동의는 합니다. <br/> 하지만 엄청난 생산성을 갖는다는것, 그리고 Apple이 추구하는 방향성의 UI Framework라는 것은 부정할 수 없기 때문에, iOS 개발자로 살면 언젠가는 사용해야하기 때문에 미리 공부해 보는 것도 좋다고 생각을 합니다.</p></div></div><div class="nextAndPreview"><div class="preview-container"><a href="/blog/SwiftUI-Need-MVVM" class="preview-link"><div class="preview-textdir"><p>Preview Post</p><h3 class="preview-title">SwiftUI에 MVVM이 필요할까요?</h3></div></a></div><div class="next-container"><a href="/blog/Swift-Compiler" class="next-link"><div class="next-textdir"><p>Next Post</p><h3 class="next-title">Swift Compiler</h3></div></a></div></div><script src="https://utteranc.es/client.js" repo="JiHoonAHN/Blog" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async></script></article><script src="/static/scripts/Channel_talk/Channel_talk.js"></script></div><footer class="site-footer"><div class="site-footer__inner"><div class="copyright"><div><p>Copyright © <a href="https://github.com/jihoonahn">Jihoonahn</a></p></div><div><p>Made with Swift</p></div></div><div class="social"><ul><li class="social_link"><a href="https://github.com/Jihoonahn"><i class="fa-brands fa-github"></i></a></li><li class="social_link"><a href="https://www.linkedin.com/in/ahnjihoon/"><i class="fa-brands fa-linkedin-in"></i></a></li><li class="social_link"><a href="https://twitter.com/jihoon_dev"><i class="fa-brands fa-twitter"></i></a></li><li class="social_link"><a href="mailto:official@jihoon.me"><i class="fa-solid fa-envelope"></i></a></li><li class="social_link"><a href="https://blog.jihoon.me/feed.rss"><i class="fa-solid fa-rss"></i></a></li></ul></div></div></footer></body></html>