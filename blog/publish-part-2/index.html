<!DOCTYPE html><html><head><meta charset="UTF-8"/><meta name="og:site_name" content="jihoon.me"/><link rel="canonical" href="https://blog.jihoon.me/blog/publish-part-2"/><meta name="twitter:url" content="https://blog.jihoon.me/blog/publish-part-2"/><meta name="og:url" content="https://blog.jihoon.me/blog/publish-part-2"/><title>Publish 사용하기 part 2</title><meta name="twitter:title" content="Publish 사용하기 part 2"/><meta name="og:title" content="Publish 사용하기 part 2"/><meta name="description" content="Swift publish 커스텀하기"/><meta name="twitter:description" content="Swift publish 커스텀하기"/><meta name="og:description" content="Swift publish 커스텀하기"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to jihoon.me"/></head><body><header id="header" class="fixed top-0 left-0 w-full z-20 bg-blog-c-nav backdrop-saturate-125 backdrop-blur-xl"><div class="pl-6 pr-4"><div class="flex justify-between mx-auto my-0 max-w-3xl"><a href="/" class="flex items-center h-blog-nav"><img src="/static/images/icon.svg" class="max-h-11 p-0"/></a><div class="flex justify-end items-center grow"><div class="flex items-center pl-4"><div id="docsearch" class="blogDocsearch"></div></div><button id="mobileNavButton" aria-label="Mobile navigation" class="cursor-pointer flex w-10 h-blog-nav items-center justify-center group md:hidden"><span class="relative h-4 w-4 overflow-hidden"><span class="transition duration-200 top-0 left-0 absolute w-full h-0.5 bg-blog-c-nav-text ease translate-x-0 translate-y-0 group-[.expanded]:rotate-45 group-[.expanded]:translate-y-0 group-[.expanded]:top-1.5"></span><span class="transition duration-200 top-1.5 left-0 absolute w-full h-0.5 bg-blog-c-nav-text ease translate-x-0 translate-y-0 group-[.expanded]:opacity-0"></span><span class="transition duration-200 top-3 left-0 absolute w-full h-0.5 bg-blog-c-nav-text ease translate-x-0 translate-y-0 group-[.expanded]:-rotate-45 group-[.expanded]:-translate-y-0 group-[.expanded]:top-1.5"></span></span></button></div><nav class="hidden md:flex"><ul class="flex list-none m-0"><li><a href="/blog" class="blogNavBarMenuLink block py-0 px-3 text-xs leading-calc-blog-nav">Blog</a></li><li><a href="/about" class="blogNavBarMenuLink block py-0 px-3 text-xs leading-calc-blog-nav">About</a></li></ul></nav></div><div id="blogNavScreen" class="hidden h-screen"><div class="my-0 mx-auto max-w-[288px] pt-6 pb-24"><nav class="inline"><ul class="list-none m-0"><li><a href="/blog" class="block py-3 blogNavBarMenuLink border-b border-zinc-500 border-solid">Blog</a></li><li><a href="/about" class="block py-3 blogNavBarMenuLink border-b border-zinc-500 border-solid">About</a></li></ul></nav><div class="mt-4 w-full"><ul class="flex justify-center gap-4 list-none"><li><a href="https://github.com/jihoonahn" class="text-center w-6 h-6"><img src="/static/icons/github.svg" class="w-6 h-6 rounded-none"/></a></li><li><a href="https://www.linkedin.com/in/ahnjihoon/" class="text-center w-6 h-6"><img src="/static/icons/linkedin.svg" class="w-6 h-6 rounded-none"/></a></li><li><a href="mailto:jihoonahn.dev@gmail.com" class="text-center w-6 h-6"><img src="/static/icons/envelope-solid.svg" class="w-6 h-6 rounded-none"/></a></li><li><a href="https://blog.jihoon.me/feed.rss" class="text-center w-6 h-6"><img src="/static/icons/rss-solid.svg" class="w-6 h-6 rounded-none"/></a></li></ul></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script><script src="/static/scripts/header.js"></script><script type="text/javascript" src="/static/scripts/docSearch.js"></script></header><main id="main" class="relative z-10 flex flex-1 flex-col min-h-screen pt-20 pb-14"><section><article><div><div class="component md:w-[654px]"><div><time class="text-gray-500 text-sm">2023년 10월 26일</time></div></div><div class="component md:w-[654px]"><div><h1 class="leading-normal font-semibold text-heading-2 md:text-heading-1">Publish 사용하기 part 2</h1></div></div><div class="component md:w-[654px]"><div class="text-lg md:text-2xl mx-auto">Swift publish 커스텀하기</div></div></div><figure class="component rounded-xl overflow-hidden min-w-[85%] lg:min-w-[320px]"><div><img src="https://github.com/jihoonahn/blog/assets/68891494/0c4b40f7-bde3-4f90-ab09-60a3eca33476" class="p-0"/></div></figure><div class="mx-auto w-[85%] text-left mt-8 md:w-[700px]"><div><h2>Publish 구조 작성하기</h2><pre><code class="language-swift">struct PublishHTMLFactory: HTMLFactory {
    typealias Site = Example

    func makeIndexHTML(for index: Publish.Index, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML {
        &lt;#code#&gt;
    }
    
    func makeSectionHTML(for section: Publish.Section&lt;Example&gt;, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML {
        &lt;#code#&gt;
    }
    
    func makeItemHTML(for item: Publish.Item&lt;Example&gt;, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML {
        &lt;#code#&gt;
    }
    
    func makePageHTML(for page: Publish.Page, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML {
        &lt;#code#&gt;
    }
    
    func makeTagListHTML(for page: Publish.TagListPage, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML? {
        &lt;#code#&gt;
    }
    
    func makeTagDetailsHTML(for page: Publish.TagDetailsPage, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; Plot.HTML? {
        &lt;#code#&gt;
    }
}
</code></pre><p>이전 포스트에서 만든 <code>PublishHTMLFactory</code> 부분 부터 보도록 하겠습니다.</p><p>Publish에서 HTML 로 구조를 작성하기 위해서, <a href="https://github.com/JohnSundell/Plot"><code>Plot</code></a>이라는 JohnSundell이 만든 라이브러리를 사용합니다.</p><p>기존에는</p><pre><code class="language-swift">let html = HTML(
    .head(
        .title("My website"),
        .stylesheet("styles.css")
    ),
    .body(
        .div(
            .h1("My website"),
            .p("Writing HTML in Swift is pretty great!")
        )
    )
)
</code></pre><p>이런 방식으로 작성했지만, Plot이 업데이트 되면서, Component 프로토콜을 사용해서 Component 요소들을 SwiftUI와 유사한 방식으로 작성할 수 있습니다.</p><pre><code class="language-swift">struct NewsArticle: Component {
    var imagePath: String
    var title: String
    var description: String

    var body: Component {
        Article {
            Image(url: imagePath, description: "Header image")
            H1(title)
            Span(description).class("description")
        }
        .class("news")
    }
}
</code></pre><p>이런 방식으로 말이죠</p><p>간단하게 알아 봤으니 한번 Publish에서 사용해보겠습니다. 먼저 가장 먼저 보일 부분인 Index 부분을 커스텀해보겠습니다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    &lt;#code#&gt;
}
</code></pre><p>먼저 <code>HTML</code>이라는 구조체를 <code>makeIndexHTML</code> 메서드에 추가해줍니다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    /// HTML 구조체 내에 node를 추가할 수 있는 형태
    HTML()

    /// HTML 구조체에 들어갈 head 부분이랑 body 부분을 init에서 분리해주는 형태
    HTML(head: [], body: {})
}
</code></pre><p>위 두가지 HTML 에서 하나를 선택해주시면 됩니다. 저는 위 방식으로 진행하도록 하겠습니다.</p><p>먼저 사용할 언어를 선택해줍니다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language) /// &lt;html lang="$(main에서 설정한 언어)"&gt;
    )
}
</code></pre><p>Head에 필요한 정보들을 넣어줍니다. 저는 publish에서 제공해주는 head static 메서드를 통해서 구성해주도록 하겠습니다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: index, on: context.site)
    )
}
</code></pre><p>빌드를 돌리게 되면</p><img width=80% src="https://github.com/jihoonahn/blog/assets/68891494/af1b26e6-2045-4775-bcae-877912ca7b84"></img><p>이런식으로 Head 부분이 쉽게 구축이 된것을 확인 할 수 있습니다. publish에서 제공하는 head 메서드는 저희가 따로 node로 넣어줄 필요없이 가장 자주 사용되는것들로 구성해 줍니다.</p><p>하지만 웹에서는 /style.css에러가 발생합니다. 이 부분은</p><pre><code class="language-swift">static func head&lt;T: Website&gt;(
    for location: Location,
    on site: T,
    titleSeparator: String = " | ",
    stylesheetPaths: [Path] = ["/styles.css"],
    rssFeedPath: Path? = .defaultForRSSFeed,
    rssFeedTitle: String? = nil
) -&gt; Node {}
</code></pre><p>head static 메서드가 선언된 부분을 보면 알 수 있습니다. <br/></p><p><code>stylesheetPath</code>에 내용이 들어가지 않기 때문에, 자동으로 style.css 부분을 넣어줘서, 현재는 style.css 파일이 없기 때문에 에러가 발생하는 것입니다.</p><pre><code class="language-swift">.head(for: index, on: context.site, stylesheetPaths: [])
</code></pre><p>그래서 아직 stylesheet 넣지 않을것이라면 이런식으로 빈 배열로 값을 넣어주면 에러가 발생하지 않습니다.</p><p>그 다음은 Body 입니다. <br/> Body 같은 경우도 node로 추가하는 방법도 있지만, 앞에서 말했던 Component를 사용해봅시다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: index, on: context.site),
        .body { 
            // Body Code
        }
    )
}
</code></pre><h2>Component 사용법</h2><p>Component를 사용하기 위해서는 <code>Component</code> 라는 프로토콜을 상속 받아줍니다.</p><pre><code class="language-swift">struct ComponentName: Component 
</code></pre><p>이렇게 상속을 받아주면</p><pre><code class="language-swift">struct ComponentName: Component {
    var body: Component {}
}
</code></pre><p>이런식으로 SwiftUI와 비슷한 스타일로 Component body 부분에서 기존에 사용하던 <code>Node</code> 또는 다른 <code>Component</code>를 이곳에 넣을 수 있습니다.</p><pre><code class="language-swift">struct ComponentName: Component {
    var body: Component {
        Div {
            ...
        }
        .class("site-div")
    }
}
</code></pre><p>이런식으로 Component를 제작할 수 있습니다.</p><p>현재 Plot에서 제공하고 있는 Component에서 사용할 수 있는 <a href="https://github.com/JohnSundell/Plot/blob/master/Sources/Plot/API/HTMLComponents.swift"><code>HTMLComponent</code></a> 입니다.</p><pre><code class="language-swift">/// A container component that's rendered using the `&lt;article&gt;` element.
public typealias Article = ElementComponent&lt;ElementDefinitions.Article&gt;
/// A container component that's rendered using the `&lt;aside&gt;` element.
public typealias Aside = ElementComponent&lt;ElementDefinitions.Aside&gt;
/// A container component that's rendered using the `&lt;button&gt;` element.
public typealias Button = ElementComponent&lt;ElementDefinitions.Button&gt;
/// A container component that's rendered using the `&lt;div&gt;` element.
public typealias Details = ElementComponent&lt;ElementDefinitions.Details&gt;
/// A container component that's rendered using the `&lt;div&gt;` element.
public typealias Div = ElementComponent&lt;ElementDefinitions.Div&gt;
/// A container component that's rendered using the `&lt;fieldset&gt;` element.
public typealias FieldSet = ElementComponent&lt;ElementDefinitions.FieldSet&gt;
/// A container component that's rendered using the `&lt;footer&gt;` element.
public typealias Footer = ElementComponent&lt;ElementDefinitions.Footer&gt;
/// A container component that's rendered using the `&lt;h1&gt;` element.
public typealias H1 = ElementComponent&lt;ElementDefinitions.H1&gt;
/// A container component that's rendered using the `&lt;h2&gt;` element.
public typealias H2 = ElementComponent&lt;ElementDefinitions.H2&gt;
/// A container component that's rendered using the `&lt;h3&gt;` element.
public typealias H3 = ElementComponent&lt;ElementDefinitions.H3&gt;
/// A container component that's rendered using the `&lt;h4&gt;` element.
public typealias H4 = ElementComponent&lt;ElementDefinitions.H4&gt;
/// A container component that's rendered using the `&lt;h5&gt;` element.
public typealias H5 = ElementComponent&lt;ElementDefinitions.H5&gt;
/// A container component that's rendered using the `&lt;h6&gt;` element.
public typealias H6 = ElementComponent&lt;ElementDefinitions.H6&gt;
/// A container component that's rendered using the `&lt;header&gt;` element.
public typealias Header = ElementComponent&lt;ElementDefinitions.Header&gt;
/// A container component that's rendered using the `&lt;li&gt;` element.
public typealias ListItem = ElementComponent&lt;ElementDefinitions.ListItem&gt;
/// A container component that's rendered using the `&lt;main&gt;` element.
public typealias Main = ElementComponent&lt;ElementDefinitions.Main&gt;
/// A container component that's rendered using the `&lt;nav&gt;` element.
public typealias Navigation = ElementComponent&lt;ElementDefinitions.Navigation&gt;
/// A container component that's rendered using the `&lt;p&gt;` element.
public typealias Paragraph = ElementComponent&lt;ElementDefinitions.Paragraph&gt;
/// A container component that's rendered using the `&lt;span&gt;` element.
public typealias Span = ElementComponent&lt;ElementDefinitions.Span&gt;
/// A container component that's rendered using the `&lt;summary&gt;` element.
public typealias Summary = ElementComponent&lt;ElementDefinitions.Summary&gt;
/// A container component that's rendered using the `&lt;caption&gt;` element.
public typealias TableCaption = ElementComponent&lt;ElementDefinitions.TableCaption&gt;
/// A container component that's rendered using the `&lt;td&gt;` element.
public typealias TableCell = ElementComponent&lt;ElementDefinitions.TableCell&gt;
/// A container component that's rendered using the `&lt;th&gt;` element.
public typealias TableHeaderCell = ElementComponent&lt;ElementDefinitions.TableHeaderCell&gt;
</code></pre><p>이부분을 통해서 Component를 제작하실때 필요한 HTML Element를 사용할 수 있습니다.</p><p>Component가 잘 제작이 됬다면</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: index, on: context.site),
        .body { 
            HeaderComponent() // 제작한 Component
            PostsLayout()     // 제작한 Component
            FooterComponent() // 제작한 Component
        }
    )
}
</code></pre><p>이런식으로 body에 넣어서 추가가 가능하죠. 간단하게 Component를 추가하는 방법에 대해서 알아보았습니다.</p><p>그럼 한번 제대로된 Publish 프로젝트 하나를 만들어보면서 어떻게 사용해야하는지 감을 잡아봅시다.</p><h2>Example</h2><p>간단하게 디자인 한 이미지를 토대로 개발해보도록 하겠습니다.</p><img width = 100% src = "https://github.com/jihoonahn/blog/assets/68891494/6155676b-0bc2-4661-825d-ad521f4b5df1"></img><p>먼저 기존에 만들어둔 Example에서 진행을 해보겠습니다.</p><pre><code>- Components
- Layouts
- Pages
- Utils
</code></pre><p>Website를 만들때 이렇게 3가지로 폴더를 분리하였습니다.</p><ul><li><code>Components</code>: <code>Components</code>는 <code>Header</code> 와 <code>Footer</code> 같은 페이지에 필요한 컴포넌트의 집합</li><li><code>Layouts</code>: <code>Layouts</code> 은 page template와 같은 재사용 가능한 UI 구조를 제공합니다.</li><li><code>Pages</code>: <code>Pages</code>는 웹사이트의 모든 페이지에 대한 레이아웃을 처리합니다.</li><li><code>Utils</code>: 코드에 추가적으로 필요한 작업이나 확장 관련된 내용이 포함이 됩니다.</li></ul><p>예시 프로젝트의 폴더에 대한 정보를 봤으니</p><p>일단 모든 페이지에서 공통적으로 사용되는 <code>Header</code>와 <code>Footer</code>부터 작업해보도록 하겠습니다.</p><p>먼저 Header입니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/06bb2285-673e-48d7-a0b3-40270bcdabf3"></img><p>Header부분을 보면 이런식으로 구성되어 있습니다. <br/> Logo를 눌렀을때 index 페이지로 이동하게 하고, section을 눌렀을 때 각각 section에 맞는 페이지로 이동을하는 기능이 필요합니다.</p><pre><code class="language-swift">struct HeaderComponent: Component
</code></pre><p>먼저 Components 부분에서 HeaderComponent라는 것을 추가하고 Component 프로토콜을 상속 받게 되면</p><pre><code class="language-swift">import Publish
import Plot

struct HeaderComponent: Component {
    var body: Component {}
}
</code></pre><p>이런식으로 body가 자동으로 만들어지고 저희는 site에 어떤 Section이 있고 사용자가 클릭한 section에 대한 정보를 가져와야 하기 때문에</p><pre><code class="language-swift">var context: PublishingContext&lt;Example&gt;
</code></pre><p><code>Publish</code> 에 있는 PublishingContext를 통해서 정보를 가져올 수 있게 합니다.</p><pre><code class="language-swift">struct HeaderComponent: Component {
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        Header {
            Link("Blog", url: "/")
                .class("header-logo")
            Div {
                Navigation {
                    List(Example.SectionID.allCases) { sectionID in
                        Link(
                            context.sections[sectionID].title,
                            url: context.sections[sectionID].path.absoluteString
                        )
                        .class("header-nav-menu-link")
                    }
                }
                .class("header-nav")
            }
            .class("content")
        }
        .class("site-header")
    }
}
</code></pre><p><code>Link</code> 같은 경우는 Html에서 <code>&lt;a&gt;</code> 태그를 담당합니다. Blog 라는 Text를 누르면 기존 타 사이트와 마찬가지로 index 페이지로 이동하도록 만들었고</p><p><code>Section</code> 부분은 List를 사용해서 저희가 <code>main.swift</code> 에 등록한 Section들을 모두 보여주게 만들었습니다.</p><p>그리고 기존 디자인에 맞춰서 코드를 넣어주고 <code>styles.css</code> 에서 style 관련 css 코드를 넣어주었습니다.</p><p>그렇게 하면 이렇게 디자인 했던 것처럼 결과 값을 받아보실 수 있습니다.</p><img src="https://github.com/jihoonahn/blog/assets/68891494/945b5880-100d-4439-ae26-b57c87cea2da"></img><p>그 다음은 Footer 입니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/20cb53bc-5a73-4155-a171-39d6bd79711d"></img><p>굉장하게 간단한 Footer 입니다.</p><p>Text로 구성하고 싶고, <code>Copyright Link</code> 부분을 누르면 저의 깃허브로 이동하도록 만들고 싶네요.</p><pre><code class="language-swift">struct FooterComponent: Component {
    var body: Component {
        Footer {
            // code
        }
        .class("site-footer")
    }
}
</code></pre><p>Component를 선언후에 Footer를 넣어주고</p><pre><code class="language-swift">struct FooterComponent: Component {
    var body: Component {
        Footer {
            Paragraph("Made with Publish")
            Paragraph {
                Text("Copyright © ")
                Link("Jihoonahn", url: "https://github.com/jihoonahn")
            }
            .class("copyright")
        }
        .class("site-footer")
    }
}
</code></pre><p>이렇게 간단하게 구축했습니다.</p><p><code>Paragraph</code> 가 HTML에서는 <code>&lt;p&gt;</code> 태그의 역할을 하고, 저희는 copyright 부분중에 Jihoonahn 이라고 적힌 부분을 눌렀을 때 깃허브로 이동시키고 싶으니 이렇게 <code>Paragraph</code> 내부에 <code>Text</code> 와 <code>Link</code> 를 넣어줍니다.</p><p>이렇게 되면 <code>"Copyright © "</code> 부분을 눌렀을 때는 링크로 이동하지 않지만, <code>Jihoonahn</code> 을 눌렀을때만 이동을 하게 됩니다.</p><p>마찬가지로 기존 디자인에 맞춰서 코드를 넣어주고 <code>styles.css</code> 에서 style 관련 css 코드를 넣어주었습니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/a7fd064d-7048-4151-9acf-7712b2474bbf"></img><p>간단하게 Header 와 Footer Component를 만들었고 한번 이제 페이지를 구축해볼까요?</p><h3>Index</h3><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: index, on: context.site, stylesheetPaths: []),
        .body {
            // Index Page
        }
    )
}
</code></pre><p>기존의 <code>HTMLFactory</code> 에서 index부분 부터 한번 작업을 해보도록하겠습니다.</p><p>Index의 Page부분을 만들기 위해서 <code>Pages</code> 폴더에서 <code>IndexPage.swift</code> 파일을 만들었습니다.</p><pre><code class="language-swift">struct IndexPage: Component {
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            FooterComponent()
        }
    }
}
</code></pre><p>여러개의 Component가 동시에 들어가기 때문에 <code>ComponentGroup</code> 로 묶어 두고 기존에 만들어둔 Header와 Footer을 넣어둡니다.</p><p>그리고 <code>Layouts</code> 폴더에 <code>PostsLayout.swift</code> 란 파일을 만들어서</p><pre><code class="language-swift">struct PostsLayout: Component
</code></pre><p><code>PostsLayout</code> 이라는 Component를 만들고</p><p>다시 IndexPage로 돌아가서</p><pre><code class="language-swift">struct IndexPage: Component {
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            PostsLayout()
            FooterComponent()
        }
    }
}
</code></pre><p>이런식으로 <code>PostsLayout</code> 도 추가로 넣어둡니다.</p><p>그리고 <code>IndexPage</code> 를 <code>HTMLFactory</code> 의 <code>makeIndexHTML</code> method에 넣어줍니다.</p><pre><code class="language-swift">func makeIndexHTML(for index: Index, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: index, on: context.site),
        .body {
            IndexPage(context: context)
        }
    )
}
</code></pre><p>그럼 이제 Index 부분을 완성하기 위해서 <code>PostsLayout</code> 부분을 채워볼까요?</p><p>Posts 같은 경우</p><img src="https://github.com/jihoonahn/blog/assets/68891494/30bdd5a9-8e18-4ffd-9817-b7a2af4ed663"></img><p>이 부분이 반복됩니다. 전체가 링크로 감싸져 있는 형태이죠.</p><p>시작하기 전에 Publish에서 확장이 되어 있지 않는 Component가 몇가지 있습니다. 그중에 PostsLayout에서 사용하고 싶은 <code>section</code> 도 아직은 존재하지 않죠</p><p>그러므로 만약 없는 Component들은 어떻게 해야하는지 보도록 하겠습니다.</p><p><code>Utils/Plot/ElementDefinitions.swift</code> 파일을 보시면 됩니다.</p><p><code>Publish</code> 의 HTML 부분을 담당하는 <code>Plot</code> 에서 <code>Section</code> 이 <code>Node</code>에서는 <code>Component</code> 타입으로 존재하지 않는것이기 때문에</p><pre><code class="language-swift">extension ElementDefinitions {
    enum Section: ElementDefinition { public static var wrapper = Node.section }
}

typealias Section = ElementComponent&lt;ElementDefinitions.Section&gt;
</code></pre><p>이런 방식으로 기존의 Plot의 <code>ElementDefinitions</code> 부분을 참고하여 확장하시면 됩니다.</p><p>이제 <code>PostsLayout</code> 을 제작해보겠습니다.</p><pre><code class="language-swift">let items: [Item&lt;Example&gt;]
</code></pre><ul><li><code>items</code> 는 Post들을 가져오는 역할을 합니다.</li></ul><p>이 프로퍼티를 추가해주고 <code>IndexPage.swift</code> 를 수정해줍니다.</p><pre><code class="language-swift">struct IndexPage: Component {
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            PostsLayout(items: context.allItems(sortedBy: \.date))
            FooterComponent()
        }
    }
}
</code></pre><p>이런 식으로 Context의 모든 Item을 들고오면서 날짜 순서대로 정렬이 되도록 해뒀습니다.</p><p>다시 <code>PostsLayout</code> 부분으로 돌아가서</p><pre><code class="language-swift">struct PostsLayout: Component {
    let items: [Item&lt;Example&gt;]
    
    var body: Component {
        Section {
            Div {
                List(items) { item in
                    Article {
                        Link(url: item.path.absoluteString) {
                            Paragraph(item.tags.map{ $0.string }.joined(separator: ", "))
                                .class("posts-tag")
                            H3(item.title)
                                .class("posts-title")
                            Paragraph(item.description)
                                .class("posts-description")
                        }
                        .class("posts-link")
                    }
                    .class("posts-article")
                }
                .class("posts-list")
            }
            .class("site-posts-inner")
        }
        .class("site-posts")
    }
}
</code></pre><p><code>items</code> 값을 <code>List(&lt;ul&gt;)</code>로 보여줄 수 있도록 제작하고 <code>styles.css</code> 에 css 코드를 넣어주면 됩니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/8db4b824-1c1e-48a0-a5f2-66e761a9ccf0"></img><p>실행을 해보면 위 Index 디자인한것과 같은 결과물을 얻을 수 있습니다.</p><p>그 다음으로는 Section 부분을 처리해보겠습니다.</p><h3>Section</h3><pre><code class="language-swift">func makeSectionHTML(for section: Publish.Section&lt;Example&gt;, context: Publish.PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: section, on: context.site),
        .body {
            // Section Code
        }
    )
}
</code></pre><p><code>HTMLFactory</code> 부분에서 <code>makeSectionHTML</code> 메서드에 Section 코드를 추가하면 됩니다.</p><pre><code class="language-swift">struct SectionPage: Component
</code></pre><p><code>Pages/Section/SectionPage.swift</code> 파일에 SectionPage라는 Component를 만들고</p><pre><code class="language-swift">var section: Publish.Section&lt;Example&gt;
var context: PublishingContext&lt;Example&gt;
</code></pre><p>Example의 <code>section</code> 과 <code>Context</code> 를 가져와 줍니다.</p><pre><code class="language-swift">struct SectionPage: Component {
    var section: Publish.Section&lt;Example&gt;
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        switch section.path.string {
        case Example.SectionID.blog.rawValue:
            return IndexPage(context: context)
        case Example.SectionID.about.rawValue:
            // About Page
        default: return Div()
        }
    }
}
</code></pre><p>이렇게 section의 path가 <code>blog</code>이면 <code>IndexPage</code>를 보여주게 하고 <code>about</code> 이라면 <code>AboutPage</code>를 보여주게 만듭니다.</p><pre><code class="language-swift">struct AboutPage: Component {
    var context: PublishingContext&lt;Example&gt;
    
    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            Div {
                Image("/images/AboutPageImage.svg")
                H2("Publish Example")
                Paragraph("Jihoonahn’s Blog Example")
            }
            .class("site-about")
            FooterComponent()
        }
    }
}
</code></pre><p>그리고 <code>SectionPage</code>에 넣어둘 <code>AboutPage</code>가 필요하기 때문에 간단하게 제작하고,</p><pre><code class="language-swift">struct SectionPage: Component {
    var section: Publish.Section&lt;Example&gt;
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        switch section.path.string {
        case Example.SectionID.blog.rawValue:
            return IndexPage(context: context)
        case Example.SectionID.about.rawValue:
            return AboutPage(context: context)
        default: return Div()
        }
    }
}
</code></pre><p>이렇게 넣어두면</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/04a19586-afba-485e-8304-10071c65af01"></img><p>이렇게 Header에 있는 <code>About</code> Section을 누르게 되면 <code>AboutPage</code> 로 이동이 되게 만들 수 있습니다.</p><h3>Post</h3><p>그 다음으로는 Index에서 Post중 하나를 눌렀을 때 그 Post의 내용을 볼 수 있도록 만들겠습니다.</p><pre><code class="language-swift">func makeItemHTML(for item: Item&lt;Example&gt;, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: item, on: context.site),
        .body {
            /// Post
        }
    )
}
</code></pre><p>이곳에 <code>post</code> 들의 item을 가져올 수 있습니다.</p><pre><code class="language-swift">struct PostLayout: Component
</code></pre><p><code>Layouts/PostLayout.swift</code> 에서 위 Index와 비슷하게 <code>PostLayout</code> 이라는 Component를 만들어주겠습니다.</p><p>그리고 <code>PostLayout</code> 부분에서 Item 내용을 가져오기 위해서</p><pre><code class="language-swift">var item: Item&lt;Example&gt;
var context: PublishingContext&lt;Example&gt;
</code></pre><ul><li><code>item</code> 프로퍼티를 통해서 가져올 수 있도록 하였습니다.</li><li><code>context</code>는 tag의 url을 가져오기 위해서 사용하였습니다.</li></ul><pre><code class="language-swift">struct PostLayout: Component {
    var item: Item&lt;Example&gt;
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        Section {
            Article {
                Div {
                    for tag in item.tags {
                        Link(tag.string, url: context.site.url(for: tag))
                            .class("post-tag")
                    }
                    H2(item.title)
                        .class("post-title")
                    Paragraph(DateFormatter.time.string(from: item.date))
                        .class("post-date")
                }
                .class("site-post-header")
                Div {
                    Div {
                        Node.contentBody(item.body)
                    }
                }
                .class("site-post-content")
            }
            .class("site-post-article")
        }
        .class("site-post")
    }
}
</code></pre><p>디자인 대로 구축한 <code>PostLayout</code> 코드입니다.</p><pre><code class="language-swift">for tag in item.tags {
    Link(tag.string, url: context.site.url(for: tag))
        .class("post-tag")
}
</code></pre><p>item에 있는 tag들을 가져와서 눌렀을때 Tag에 관련된 Post를 찾을 수 있는 페이지로 이동시킵니다.</p><pre><code class="language-swift">Node.contentBody(item.body)
</code></pre><p>그리고 저희가 <code>Content</code> 파일에 markdown으로 추가한 내용을 볼 수 있도록 <code>Node</code> 의 <code>contentBody</code> 메서드를 사용해주시면 됩니다.</p><pre><code class="language-swift">struct PostPage: Component {
    var item: Item&lt;Example&gt;
    var context: PublishingContext&lt;Example&gt;

    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            PostLayout(item: item, context: context)
            FooterComponent()
        }
    }
}
</code></pre><p>그리고 <code>PostLayout</code>을 만들었으니, <code>PostPage</code> 에 <code>PostLayout</code>을 가져와주시면 됩니다.</p><pre><code class="language-swift">func makeItemHTML(for item: Item&lt;Example&gt;, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: item, on: context.site),
        .body {
            PostPage(item: item, context: context)
        }
    )
}
</code></pre><p>다시 <code>HTMLFactory</code> 부분으로 돌아가서 <code>PostPage</code> 부분을 body에 넣어주시면</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/1043641c-3e1e-4bec-bc31-6612f6a0bfdf"></img><p>이렇게 Markdown에 있는 Post가 잘 작동하는 것을 확인할 수 있습니다.</p><h3>Page</h3><p><code>makePageHTML</code> 부분은 특별하게 예시에서는 사용하고 있지 않기 때문에</p><pre><code class="language-swift">func makePageHTML(for page: Page, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML {
    HTML(
        .lang(context.site.language),
        .head(for: page, on: context.site),
        .body {
            page.body
        }
    )
}
</code></pre><p><code>page.body</code> 만 보이게 해뒀습니다.</p><h3>Tag List</h3><p>그 다음은 <code>TagList</code> 입니다. Post에 있는 모든 Tag들을 한번에 가져와서 볼 수 있게 하는 역할을 합니다.</p><pre><code class="language-swift">func makeTagListHTML(for page: Publish.TagListPage, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML? {
    HTML(
        .lang(context.site.language),
        .head(for: page, on: context.site),
        .body {
            // TagList Code                
        }
    )
}
</code></pre><p><code>HTMLFactory</code> 부분에서 <code>makeTagListHTML</code> 에서 처리할 수 있습니다.</p><pre><code class="language-swift">struct TagListPage: Component
</code></pre><p>먼저 <code>TagListPage</code> 에서 마찬가지로 Component를 생성하고</p><pre><code class="language-swift">let tags: Set&lt;Tag&gt;
</code></pre><p><code>TagListPage</code>에서는 <code>Publish.TagListPage</code>에 있는 모든 태그를 들고 올 수 있게 <code>Set&lt;Tag&gt;</code> 타입을 사용합니다.</p><pre><code class="language-swift">struct TagListPage: Component {
    let tags: [Tag]
    let context: PublishingContext&lt;Example&gt;
    
    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            List(tags) { tag in
                ListItem {
                    Link(tag.string, url: context.site.url(for: tag))
                }
                .class("site-tag")
            }
            .class("site-tagList")
            FooterComponent()
        }
    }
}
</code></pre><p>그리고 <code>tags</code> 를 List에 넣어서 보여주고 <code>styles.css</code> 에서 간단한 css 코드만 추가해주었습니다.</p><pre><code class="language-swift">func makeTagListHTML(for page: Publish.TagListPage, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML? {
    HTML(
        .lang(context.site.language),
        .head(for: page, on: context.site),
        .body {
            TagListPage(tags: page.tags, context: context)
        }
    )
}
</code></pre><p>다시 <code>HTMLFactory</code> 코드로 돌아와서 <code>TagListPage</code>를 넣어줍니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/f069ee2d-da19-4d8a-a44e-9e1dd386174b"></img><p>이렇게 디자인과 같은 TagList 페이지를 얻을 수 있습니다.</p><h3>TagDetail</h3><p>마지막 <code>TagDetail</code> 부분입니다. 지정된 tag를 눌렀을 때 이 tag를 가지고 있는 post를 보여주는 역할을 합니다.</p><pre><code class="language-swift">func makeTagDetailsHTML(for page: Publish.TagDetailsPage, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML? {
    HTML(
        .lang(context.site.language),
        .head(for: page, on: context.site),
        .body {
            // Tag Details Code
        }
    )
}
</code></pre><p><code>HTMLFactory</code>에서 마지막 하나 남은 메서드인 <code>makeTagDetailsHTML</code> 에서 작업을 하실 수 있습니다.</p><pre><code class="language-swift">struct TagDetailPage: Component
</code></pre><p><code>TagDetailPage</code>라는 Component를 선언하고</p><pre><code class="language-swift">let items: [Item&lt;Example&gt;]
let selectedTag: Tag
</code></pre><ul><li><code>items</code>: Tag에 포함된 post들을 가져옵니다.</li><li><code>selectedTag</code>: 선택된 Tag의 정보를 알려줍니다.</li></ul><p>위의 프로퍼티들을 추가해주시고</p><pre><code class="language-swift">struct TagDetailsPage: Component {
    let items: [Item&lt;Example&gt;]
    let context: PublishingContext&lt;Example&gt;
    let selectedTag: Tag

    var body: Component {
        ComponentGroup {
            HeaderComponent(context: context)
            Div {
                H2(selectedTag.string)
                PostsLayout(items: items)
            }
            .class("site-tagDetails")
            FooterComponent()
        }
    }
}
</code></pre><p>기존의 <code>PostsLayout</code> 을 가져오는 방식으로 간단하게 처리하고</p><pre><code class="language-swift">func makeTagDetailsHTML(for page: Publish.TagDetailsPage, context: PublishingContext&lt;Example&gt;) throws -&gt; HTML? {
    HTML(
        .lang(context.site.language),
        .head(for: page, on: context.site),
        .body {
            TagDetailsPage(
                items: context.items(
                    taggedWith: page.tag,
                    sortedBy: \.date
                ),
                context: context,
                selectedTag: page.tag
            )
        }
    )
}
</code></pre><p>이렇게 <code>HTMLFactory</code>의 <code>makeTagDetailsHTML</code>에 넣어주시면 되는데,</p><pre><code class="language-swift">items: context.items(
    taggedWith: page.tag,
    sortedBy: \.date
),
</code></pre><p><code>items</code>를 가져오는 부분을 보면 context의 items를 가져오는데 <code>page.tag</code>가 포함되어 있는 <code>item</code> 만 가져오게 해준다라고 생각하시면 될것 같습니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/30e5ace0-1f7e-408a-b779-687e48114af1"></img><p>이런식으로 Tag를 눌렀을때 잘 조회가 되는것을 확인할 수 있습니다. 이렇게 해서 저희는 Publish로 웹사이트 하나를 뚝딱 만들어 봤습니다.</p><p>위에서 진행한 내용은 <a href="https://github.com/Jihoonahn/Blog-Document/tree/main/Publish/part2">예시코드</a> 를 확인할 수 있습니다.</p><p>--- 이번 글에서는 Publish에서 HTML을 작성하는 방법과, 직접 예제를 만들어보며 Publish를 이용해서 실질적인 웹사이트를 만들어 봤습니다.</p><p>다음글에서는 Publish로 만든 웹사이트를 배포하는 법에 대해서 작성할 예정입니다.</p></div></div><div class="flex flex-col-reverse px-4 mt-11 mb-4 max-w-3xl mx-auto md:flex-row md:px-0"><div class="min-w-0 flex-1 mt-4 md:mt-0"><a href="/blog/publish-part-1" class="flex cursor-pointer rounded-[10px] bg-blog-c-preview-page w-full h-full p-4 min-h-[4.2rem] items-center"><div class="flex-1 flex flex-col leading-none min-w-0 items-start"><p class="text-gray-500 m-0.5">Preview Post</p><h3 class="text-black text-2xl font-medium m-0.5">Publish 사용하기 part 1</h3></div></a></div><div class="min-w-0 flex-1 mt-4 md:mt-0 md:ml-8"></div></div><script src="https://utteranc.es/client.js" repo="jihoonahn/blog" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async></script></article></section></main><footer class="bg-blog-c-footer relative"><div class="flex flex-wrap justify-between p-1 mx-auto max-w-4xl"><div class="text-sm mx-3 my-auto p-2"><div><p class="text-stone-600 my-0">Copyright © <a href="https://github.com/jihoonahn" class="text-stone-700">Jihoonahn</a></p></div><div><p class="text-stone-600 my-0">Made with Swift</p></div></div><div class="mx-2"><ul class="inline-flex gap-4 list-none"><li class="text-center w-4 h-4"><a href="https://github.com/jihoonahn"><img src="/static/icons/github.svg" class="w-full h-auto rounded-none"/></a></li><li class="text-center w-4 h-4"><a href="https://www.linkedin.com/in/ahnjihoon/"><img src="/static/icons/linkedin.svg" class="w-full h-auto rounded-none"/></a></li><li class="text-center w-4 h-4"><a href="mailto:jihoonahn.dev@gmail.com"><img src="/static/icons/envelope-solid.svg" class="w-full h-auto rounded-none"/></a></li><li class="text-center w-4 h-4"><a href="https://blog.jihoon.me/feed.rss"><img src="/static/icons/rss-solid.svg" class="w-full h-auto rounded-none"/></a></li></ul></div></div></footer></body></html>