<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Jihoon.me</title><description>This is a personal blog for iOS Developer Jihoonahn.</description><link>https://blog.jihoon.me</link><language>en</language><lastBuildDate>Fri, 9 Jun 2023 17:23:14 +0000</lastBuildDate><pubDate>Fri, 9 Jun 2023 17:23:14 +0000</pubDate><ttl>250</ttl><atom:link href="https://blog.jihoon.me/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.jihoon.me/blog/How-to-use-Tuist-on-Xcode-Beta</guid><title>Xcode-Beta에서 Tuist 사용기</title><description>Xcode Beta에서 tuist edit 명령어에서 에러나는 부분을 해결하는 방법에 대한 포스트입니다.</description><link>https://blog.jihoon.me/blog/How-to-use-Tuist-on-Xcode-Beta</link><pubDate>Sat, 10 Jun 2023 00:03:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘의 Xcode-Beta 버전에서 Tuist 사용방법에 대해서 막힌 부분과 해결방법에 대해서 이야기 해보려고 합니다.</p><p>일단 시작해보겠습니다!</p><hr><h2>Beta를 사용했을때</h2><p>최근에 WWDC23이 공개되었습니다. macOS에서 발표된 내용을 보고 macOS 14와 Xcode 15의 변화에 대해서 보기 위해서, 업데이트를 했습니다.</p><img width="10%" src="https://github.com/Jihoonahn/Blog/assets/68891494/9042ff22-337c-459b-b01b-4ab7718c4bcd"></img><p>그렇게 봉인된.. Xcode..</p><p>macOS 14에서는 기존 Xcode 14.3.1(글 작성 기준)를 사용하지 못하게 됩니다. <br/> 그래서 Xcode 15를 설치해야합니다.</p><p><a href="https://xcodereleases.com/">Xcode 설치 링크</a></p><h2>어떤 문제가 있었나..</h2><p>그렇게, Xcode 15를 설치하고 Tuist를 실행 했을 때, 이런 문제가 있더군요. Tuist에서 <code></code>tuist edit<code></code> 명령어를 실행했을 때,</p><img width="60%" src="https://github.com/Jihoonahn/Blog/assets/68891494/c22e5b50-273a-45ab-a96e-484d715b014a"></img><p>이런 식으로 실행이 안되는 문제가 있었습니다. <br/> 이유는.. 위에서 빌드업 했지만, 문제는 <a href="https://github.com/tuist/tuist/blob/main/Sources/TuistKit/Services/EditService.swift">Tuist Command Service</a> 부분에 있었습니다. <br/></p><h2>문제는 어디서?</h2><img width="80%"  src="https://github.com/Jihoonahn/Blog/assets/68891494/7455feac-8ad3-4877-968f-7675681f31d1"></img><p>위 코드부분에서 에러가 발생합니다. <br/> Xcode 앱을 실행시키는 코드이고, 현재 Xcode는 위 그림처럼 봉인(?)당했기 때문에 Xcode앱을 열 수 없는 것입니다. <br/> 나머지 명령어에서는 문제가 없었지만, <code></code>tuist edit<code></code> 명령어에서만 문제가 생기더라고요. <br/> 이 문제에 대한 해결 방법은 없을까요? <br/></p><h2>해결 방법</h2><h3>1. Tuist 명령어만으로 해결하는 방법</h3><img width="50%" src="https://github.com/Jihoonahn/Blog/assets/68891494/cd7a8e9c-59c0-435b-9ff2-bb124bb8d9f8"></img><p><code></code>tuist edit -h<code></code>를 실행시켜 명령어를 찾아봅시다.</p><p>Tuist 공식 깃허브 코드에서는 permanent가 true면, Xcode앱을 실행시키지 않습니다.</p><pre><code><span class="keyword">let</span> workspacePath = <span class="keyword">try</span> projectEditor.<span class="call">edit</span>(
    at: path,
    in: path,
    onlyCurrentDirectory: onlyCurrentDirectory,
    plugins: plugins
)
logger.<span class="call">notice</span>(<span class="string">"Xcode project generated at</span> \(workspacePath.<span class="property">pathString</span>)<span class="string">"</span>, metadata: .<span class="dotAccess">success</span>)
</code></pre><p>그렇기 떄문에, <code></code>tuist edit --permanent<code></code> 명령어를 실행하면?</p><img width="80%" src="https://github.com/Jihoonahn/Blog/assets/68891494/f71302cb-91ad-4e0c-a665-52dde3574409"></img><p>에러가 발생하여 동작이 실패하지 않고, 아래 처럼 프로젝트와 워크스페이스 파일이 생성됩니다.</p><img width="80%" src="https://github.com/Jihoonahn/Blog/assets/68891494/21ac8d5b-9353-4d04-846f-edaa4103fc0d"></img><p>이런식으로 진행이 됬다면, Manifests.xcworkspace 파일을 눌러서, tuist 프로젝트를 수정할 수 있습니다.</p><h3>2. xcode-select의 path를 변경하는 방법</h3><img width="50%" src="https://github.com/Jihoonahn/Blog/assets/68891494/7c9fb32e-6ea6-4154-99c3-fc4c470ad8f2"></img><p>이 방법은 <a href="https://github.com/baekteun">baekteun</a> 이라는 후배가 영감을 준 방법입니다.</p><p>터미널에서</p><pre><code>sudo xcode-select -s /<span class="type">Applications</span>/<span class="type">Xcode</span>-beta.<span class="property">app</span>/<span class="type">Contents</span>/<span class="type">Developer</span>
</code></pre><p>이렇게 xcode-select에서 path를 변경해 줍니다.</p><p>그 이후 다시 <code></code>tuist edit<code></code> 명령어를 실행하면 됩니다.</p><img width="50%" src="https://github.com/Jihoonahn/Blog/assets/68891494/ef3d3550-e18a-4d1b-8d76-2e8017574897"></img><p>그렇게 되면 정상적으로 <code></code>tuist edit<code></code> 명령어가 작동합니다.</p><p>---</p><h2>후기</h2><p>처음에 <code></code>tuist edit<code></code> 명령어가 작동하지 않아서 tuist의 명령어 코드를 보다가 첫번째 방법은 발견하게 되었고, 두번째 방법은 위에서 말했듯 후배에게 영감을 받아서 얻은 방법입니다.</p><p>Tuist에서 <code></code>Sources/TuistSupport/Xcode/XcodeController.swift<code></code> 부분을 보게 되면, <code></code>xcode-select -p<code></code> 를 통해서 Xcode의 developer 파일 경로를 받아오는 방식입니다.</p><pre><code><span class="comment">/// Returns the selected Xcode. It uses xcode-select to determine
/// the Xcode that is selected in the environment.
///
/// - Returns: Selected Xcode.
/// - Throws: An error if it can't be obtained.</span>
<span class="keyword">public func</span> selected() <span class="keyword">throws</span> -&gt; <span class="type">Xcode</span>? {
    <span class="comment">// Return cached value if available</span>
    <span class="keyword">if let</span> cached = selectedXcode {
        <span class="keyword">return</span> cached
    }

    <span class="comment">// e.g. /Applications/Xcode.app/Contents/Developer</span>
    <span class="keyword">guard let</span> path = <span class="keyword">try</span>? <span class="type">System</span>.<span class="property">shared</span>.<span class="call">capture</span>([<span class="string">"xcode-select"</span>, <span class="string">"-p"</span>]).<span class="call">spm_chomp</span>() <span class="keyword">else</span> {
        <span class="keyword">return nil</span>
    }

    <span class="keyword">let</span> xcode = <span class="keyword">try</span> <span class="type">Xcode</span>.<span class="call">read</span>(path: <span class="keyword">try</span> <span class="type">AbsolutePath</span>(validating: path).<span class="property">parentDirectory</span>.<span class="property">parentDirectory</span>)
    selectedXcode = xcode
    <span class="keyword">return</span> xcode
}
</code></pre><p>근데 처음에 시도할때는 <code></code>xcode-select<code></code> 명령어의 option에서 path를 따로 바꿀 수 있다는 사실을 망각하고 있었기 때문에, 다양한 방식을 찾은 거 같습니다.</p><p>어쨋든 Xcode-beta 또는 다른 버전의 Xcode 앱을 설치하고 <code></code>tuist edit<code></code> 명령어가 작동하지 않아서 당황하신 분들을 위해서 이 글을 적었습니다.</p><p>이 방식 외 더 좋은 방식에 대해서 알고 계신 분이 있다면, blog 댓글에 알려주세요.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Universal-Framework</guid><title>Universal Framework</title><description>Universal Framework에 대한 공부</description><link>https://blog.jihoon.me/blog/Universal-Framework</link><pubDate>Sun, 2 Apr 2023 18:30:00 +0000</pubDate><content:encoded><![CDATA[<p>이번 포스트에서는 Universal Framework에 대해서 공부 해보겠습니다.</p><p>옛날에 Framework를 만들 때 편하게 사용을 해서, 이번 포스트에 담아보는것이 좋겠다고 생각이 들었습니다.</p><p>일단 시작해보겠습니다!</p><hr><h3>Universal Framework (범용 프레임워크)</h3><p>디바이스와 시뮬레이터에서 사용가능하도록 범용적으로 프레임워크를 만드는 것입니다. <br/> Device에서의 OS, SimulatorOS 둘 모두에 적용하기 위해서는 Valid Architecture가 모두 존재해야합니다. iPhone OS에서의 CPU와, macOS에서의 경우 시뮬레이터의 구동을 위해서는 macOS의 CPU가 구현되어 맞춰줘야 합니다. <br/></p><p>이러한 문제점을 해결하기 위해서 나온 것이 Universal Framework입니다. <br/></p><h3>Universal Framework 의 장점</h3><ul><li>코드 재사용성이 올라간다.</li><li>코드 숨기가 쉬워진다.</li><li>코드 모듈화에 이점을 갖는다.</li><li>쉬운 통합이 가능하다.</li><li>쉽게 배포할 수 있다.</li></ul><h3>사용법</h3><p>Target 아래쪽에 있는 + 버튼을 누릅니다. 그 후 Other -&gt; Aggregate를 추가합니다. (Framework와 XCFramework 둘다 생성해줍니다.)</p><img width="100%" src="https://user-images.githubusercontent.com/68891494/230734262-75b7f72f-2fcb-4e3c-b4ab-540aef965dbe.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230734362-64553040-5617-4c18-88b3-fda6d5e38cdc.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230734363-8b0e9098-a026-4ed1-8ef8-aa298ecf3c5c.png"></img><br/><h2>Add Script</h2><p>각각의 Aggregate에 Script를 추가해줍니다.</p><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735301-2f7b56e2-f9d7-4265-b4a6-53f4faa975f2.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735305-e7f7eb72-bdec-4032-af50-554bdc78fafb.png"></img><h4>XCFramework</h4><pre><code># <span class="type">Build Device</span> and <span class="type">Simulator</span> versions
xcodebuild archive -scheme <span class="string">"${PROJECT_NAME}"</span> -archivePath <span class="string">"${BUILD_DIR}/iphoneos.xcarchive"</span> -sdk iphoneos <span class="type">SKIP_INSTALL</span>=<span class="type">NO BUILD_LIBRARY_FOR_DISTRIBUTION</span>=<span class="type">YES</span>
xcodebuild archive -scheme <span class="string">"${PROJECT_NAME}"</span> -archivePath <span class="string">"${BUILD_DIR}/iphonesimulator.xcarchive"</span> -sdk iphonesimulator <span class="type">SKIP_INSTALL</span>=<span class="type">NO BUILD_LIBRARY_FOR_DISTRIBUTION</span>=<span class="type">YES</span>

xcodebuild -create-xcframework \
    -framework <span class="string">"${BUILD_DIR}/iphoneos.xcarchive/Products/Library/Frameworks/"${PROJECT_NAME}".framework"</span> \
    -framework <span class="string">"${BUILD_DIR}/iphonesimulator.xcarchive/Products/Library/Frameworks/"${PROJECT_NAME}".framework"</span> \
    -output <span class="string">"${BUILD_DIR}/"${PROJECT_NAME}".xcframework"</span>

    
# <span class="type">Copy</span> the xcframework to the project directory
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/"${PROJECT_NAME}".xcframework" "${PROJECT_DIR}"</span>

# <span class="type">Open</span> the project directory <span class="keyword">in</span> <span class="type">Finder</span>
<span class="keyword">open</span> <span class="string">"${PROJECT_DIR}"</span>
</code></pre><h4>Framework</h4><pre><code><span class="type">UNIVERSAL_OUTPUTFOLDER</span>=${<span class="type">BUILD_DIR</span>}/${<span class="type">CONFIGURATION</span>}-<span class="type">Universal</span>
  
# <span class="type">Make</span> sure the output directory exists
mkdir -p <span class="string">"${UNIVERSAL_OUTPUTFOLDER}"</span>
  
# <span class="type">Build Device</span> and <span class="type">Simulator</span> versions
xcodebuild -target <span class="string">"${PROJECT_NAME}"</span> <span class="type">BITCODE_GENERATION_MODE</span>=bitcode <span class="type">OTHER_CFLAGS</span>=<span class="string">"-fembed-bitcode"</span> <span class="type">ONLY_ACTIVE_ARCH</span>=<span class="type">NO</span> -configuration ${<span class="type">CONFIGURATION</span>} -sdk iphonesimulator <span class="type">BUILD_DIR</span>=<span class="string">"${BUILD_DIR}"</span> <span class="type">BUILD_ROOT</span>=<span class="string">"${BUILD_ROOT}"</span> clean build
xcodebuild -target <span class="string">"${PROJECT_NAME}"</span> <span class="type">BITCODE_GENERATION_MODE</span>=bitcode <span class="type">OTHER_CFLAGS</span>=<span class="string">"-fembed-bitcode"</span> <span class="type">ONLY_ACTIVE_ARCH</span>=<span class="type">NO</span> -configuration ${<span class="type">CONFIGURATION</span>} -sdk iphoneos  <span class="type">BUILD_DIR</span>=<span class="string">"${BUILD_DIR}"</span> <span class="type">BUILD_ROOT</span>=<span class="string">"${BUILD_ROOT}"</span> clean build
  
  
# <span class="type">Copy</span> the framework structure (from iphoneos build) to the universal folder
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework" "${UNIVERSAL_OUTPUTFOLDER}/"</span>
  
# <span class="type">Copy Swift</span> modules from iphonesimulator build (if it exists) to the copied framework directory
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/." "${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule"</span>
  
# <span class="type">Create</span> universal binary file using lipo and place the combined executable <span class="keyword">in</span> the copied framework directory
lipo -create <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/${PROJECT_NAME}" "${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework/${PROJECT_NAME}"</span> -output <span class="string">"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}"</span>
  
# <span class="type">Copy</span> the framework to the project directory
cp -<span class="type">R</span> <span class="string">"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework" "${PROJECT_DIR}"</span>
  
# <span class="type">Open</span> the project directory <span class="keyword">in</span> <span class="type">Finder</span>
<span class="keyword">open</span> <span class="string">"${PROJECT_DIR}"</span>
</code></pre><br/><h2>Run</h2><img width="50%" src="https://user-images.githubusercontent.com/68891494/230735382-bb57dcae-094d-41fd-bbac-a67d58238720.png"></img><p>각각 원하는 Aggregate Scheme를 선택하고 빌드하면 됩니다.</p><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735710-e91d3125-07ac-4725-a878-64c378dcfa28.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735711-ad3a28d2-a6c9-4d8f-a44a-b6ac63ebfaa8.png"></img><p>좌 Framework Aggregate로 빌드 했을 때, 우 XCFramework Aggregate로 빌드 했을 때</p><br/><h2>Reference</h2><ul><li><a href="https://magicmon.tistory.com/225">tistory</a></li><li><a href="https://medium.com/macoclock/swift-universal-framework-3bc858224a7c">medium</a></li><li><a href="https://github.com/kstenerud/iOS-Universal-Framework">kstenerud/iOS-Universal-Framework</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/ABI</guid><title>ABI</title><description>Application Binary Interface에 대한 공부</description><link>https://blog.jihoon.me/blog/ABI</link><pubDate>Sun, 2 Apr 2023 17:55:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘 <strong>ABI</strong> (Application Binary Interface)에서 어떤 역할을 하는지 알아보겠습니다.</p><p>일단 시작해보겠습니다!</p><hr><h2>ABI란?</h2><p>위에서도 말했던 Application Binary Interface 의 약자로 바이너리간의 인터페이스를 나타냅니다. Runtime 내에서 Swift 프로그램 바이너리는 ABI를 통해 다른 라이브러리 및 구성요소와 상호작용한다는 특징이 있습니다.</p><h2>ABI stability</h2><p>Swift 5.0 부터 지원하게 된 ABI stability는 바이너리 내부는 바뀔 수 있지만 인터페이스는 유지되기 때문에 ABI stability가 지원이 되면 ABI가 지원하는 버전의 Swift Compiler를 통해 컴파일한 앱과 이후 업데이트 된 바이너리 간의 호환이 가능합니다.</p><img width="100%" src ="https://www.swift.org/assets/images/abi-stability-blog/abi-stability.png"></img><p>위 이미지 예시에서는 Swift 5로 빌드된 앱은 Swift 5 표준 라이브러리와 가상의 Swift 5.1, 6에도 실행이 된다는 것을 보여줍니다. <br/></p><blockquote><p>ABI에 대해서 이해가 되셨나요?<br/>그러면 ABI를 사용하면 어떤 이점을 얻을 수 있을까요?</p></blockquote><h2>이점</h2><p><strong>Source compatibility(소스 호환성)</strong></p><ul><li>새로운 Swift 버전이 나왔을 때 마이그레이션 을 해야하는 비용을 줄일 수 있습니다.</li></ul><p><strong>Binary framework &amp; runtime compatibility</strong></p><ul><li>Binary framework &amp; runtime compatibility를 통해 여러가지 버전에서 작동하는 Framework를 배포할 수 있습니다. <br/><br/></li></ul><h2>Reference</h2><ul><li><a href="https://www.swift.org/blog/abi-stability-and-more/">ABI stability in swift.org</a></li><li><a href="https://github.com/apple/swift/blob/main/docs/ABIStabilityManifesto.md">swift github</a></li><li><a href="https://medium.com/@rahulnakeel9898/abi-stability-3ed7f3f84177">medium</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Scade-Introduce</guid><title>Scade 소개</title><description>Swift로 크로스플랫폼 만드는 방법을 아시나요?</description><link>https://blog.jihoon.me/blog/Scade-Introduce</link><pubDate>Fri, 17 Mar 2023 21:24:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘의 Post는 Swift로 CrossPlatform 개발이 가능하게 하는 Scade에 대한 소개글입니다. 좀 많이 마이너해서.. 다들 처음 들어봤을 확률이 굉장히 높지만 흥미를 가질 수 있는 주제라서 글을 작성하게 되었습니다.</p><h3>What is Scade?</h3><p>Swift로 iOS 와 Android 개발을 동시에 할 수 있는 크로스 플랫폼입니다.</p><img width = 100% src = "https://user-images.githubusercontent.com/68891494/225908911-ad6d8638-99a4-496e-ad4e-ccc62238fe81.png"></img><p><a href="https://www.scade.io">scade.io</a></p><p>전용 툴을 제공하며, 위 <a href="https://www.scade.io/download/">링크</a>에서 다운 받을 수 있다. <br/> Scade의 <a href="https://docs.scade.io/docs">공식문서</a> 입니다.</p><hr><h3>어떻게 동작되는 걸까?</h3><p>Swift코드를 네이티브 iOS와 Android를 바이너리로 컴파일하여, 앱을 빌드합니다. <br/> 현재 기준 Scade는 Swift 5.4를 지원합니다.</p><img width = 100% src = "https://files.readme.io/448093c-scadecompiler.png"></img><p>위 링크를 통해 전용 툴을 다운로드 받았다면</p><img width=20% src = "https://user-images.githubusercontent.com/68891494/225911086-829ed397-231c-42f8-9286-30a14cea8887.png"></img><p>이러한 어플리케이션을 확인할 수 있을겁니다.</p><p>그리고 Xcode와 AndroidStudio 설치까지 마치셨다면, <a href="https://docs.scade.io/docs/getting-started">공식문서</a>를 보고 세팅해주시면 됩니다.</p><p><strong>중요</strong></p><img width=100% src = "https://files.readme.io/353f9ab-Screenshot_2022-10-20_at_09.51.18.jpeg"></img><p>이 부분의 세팅할 때 주의하시는 것이 좋습니다.</p><h3>프로젝트 생성하기</h3><p>IDE 내부에서 FILE| Name | New Project 로 프로젝트를 생성해줍니다.</p><img width=51% alt="스크린샷 2023-03-18 오후 3 38 06" src="https://user-images.githubusercontent.com/68891494/226089798-20eb3b08-1c00-4aef-9c32-88c18c04909e.png"></img><img width=39% alt="스크린샷 2023-03-18 오후 3 38 20" src="https://user-images.githubusercontent.com/68891494/226089897-4f4940d2-fc90-4e21-9da5-11f00456b2a4.png"></img><p>Scade IDE에서 프로젝트를 생성해주면 됩니다.</p><img width=30% src = "https://user-images.githubusercontent.com/68891494/226188230-d29f816d-d73a-42b0-803d-ec8498550584.png"></img><p>Scade같은 경우 3가지 종류의 로 빌드가 가능합니다. <br/> 자체 시뮬레이터인 Scade Simulator, iOS의 Simulator, Android Emulator</p><p>뷰 같은 경우 .page 파일에서 스토리보드와 비슷하게 되어 있는것을 확인 할 수 있고,</p><img width = 100% src = "https://user-images.githubusercontent.com/68891494/226189250-92402bc0-7f11-428a-bbea-af726f0136b3.png"></img><p>우측 + 버튼을 눌러서 Component를 가져올 수 있습니다.</p><img width = 40% src = "https://user-images.githubusercontent.com/68891494/226189421-2d4ff86a-4841-4091-9b52-11c74ecb27d1.png"></img><p>원하는 컴포넌트를 Drag &amp; Drop 해주면 됩니다. (Storyboard와 같은 느낌이죠?)</p><img width=80% src = "https://user-images.githubusercontent.com/68891494/226189572-c1c21fb6-0568-4466-9aed-8877b4c1f87a.png"></img><p>Scade IDE 우측에 있는 옵션들을 수정하여, Component를 설정 할 수도 있습니다.</p><h3>실행</h3><p>한번 Android와 iOS에서 잘 돌아가는지 확인해 보겠습니다.</p><img width=30% src = "https://user-images.githubusercontent.com/68891494/226190161-740185f6-9375-40de-aec8-ba1d46580936.png"></img><img width=30% src = "https://user-images.githubusercontent.com/68891494/226190164-d5458e5c-9a96-4998-8c02-9037a8d4a2bc.png"></img><p>좌 Android Emulator, 우 iOS Simulator</p><p>같은 UI로 잘 돌아가는 것을 확인 할 수 있습니다.</p><h3>Scade를 사용해보고 느낀점</h3><p>현재 꾸준히 개발되고 있지만 현재는 Beta 버전이고, 현재 공개된 <a href="https://github.com/scade-platform">Scade Platform Github</a>는 이곳입니다. 아쉽게도 Scade SDK는 오픈소스는 아니기 때문에 뭔가 아쉽다 라는 느낌을 받긴 했지만, Swift로 iOS, Android CrossPlatform 개발이 된다는 점에서 신기한 느낌을 받고, IDE에서 Storyboard와 같은 기능을 지원하는것도 신기했습니다.</p><p>아직 부족한 부분은 분명 있지만 현재 베타버전임을 감안하고, 몇년에 걸쳐서 개발이 되는것을 보아, <br/> 추후 정식 출시날도 기다려집니다.</p><p>제가 개인적으로 느낀 점은, 그저 신기하다에 그치지 않고 Scade는 생각보다 놀라운 도구 였습니다. <br/></p><p>저의 주 언어인 Swift를 가지고 Android 와 iOS를 동시 개발 가능하게 해주기 때문에, 저에게는 큰 흥미를 주었던 것 같습니다.</p><p>현재 Scade의 미래가 어떻게 될지 모르지만 Scade는 Beta에서만 끝나지 않고, 늦어도 좋으니 정식 출시까지 했으면 좋겠다는 생각이 들었습니다. (추후 Apple에서 비슷한 걸 제공해도 좋고요 ㅎㅎ)</p><hr><br/><p>이번에는 Scade에 대해서 소개하는 글이기 때문에, 간단하게 소개했기 때문에 여기에서 글을 끝내고 <br/> 나중에 Scade를 더 깊게 사용해보며, 글을 적도록 하겠습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/LLDB</guid><title>LLDB</title><description>LLDB를 이용해 디버깅하기</description><link>https://blog.jihoon.me/blog/LLDB</link><pubDate>Sat, 25 Feb 2023 01:39:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘의 Post에서는 LLDB 에 대해서 공부해 볼 것입니다.</p><p>더 LLDB를 잘 사용하기 위해서 이 글을 정리합니다.</p><p>일단 시작해보겠습니다!</p><hr><h2>What is LLDB?</h2><p>LLDB는 Low-Level Debbuger의 약자로 LLVM Debbuger 컴포넌트를 개발하는 애플의 서브 프로젝트이며, 우리가 사용하는 Xcode의 기본으로 내장되어 있는 디버거 입니다. <br/> Xcode IDE의 Terminal에 곧바로 접근해서 실행중인 프로세스 값을 변경하거나, 흐름을 제어하는 등 다양한 디버깅 작업을 할 수 있습니다!</p><h2>And What is LLVM?</h2><p>LLVM은 Low-level Virtual Machine의 약어로 LLVM은 intermediate / binary 기계 코드를 구성, 최적화 및 생성하는데 사용하는 라이브러리라고 생각하면 될것 같습니다. <br/> 추후 LLVM에 대한 자세한 포스트는 나중에 정리하겠습니다.</p><br/><h2>Commands</h2><p>LLDB에서는 유용한 명령어가 많기 때문에 오늘은 무슨 명령어가 있는지 알아보겠습니다.</p><img width = 100% src = "https://user-images.githubusercontent.com/68891494/221356567-0fcb2381-dfd9-459e-a2b4-bc11dfceb7e7.png"></img><p><a href="https://www.dropbox.com/s/9sv67e7f2repbpb/lldb-commands-map.png?dl=0">Download full size version with this link</a></p><br/><h5>LLDB의 기초 문법</h5><pre><code>(lldb) command [subcommand] -option <span class="string">"this is argument"</span>
</code></pre><ul><li>Command와 subCommand는 LLDB의 Object의 이름을 표기한다.</li><li>LLDB동작은 Xcode에서 브레이크 포인트를 걸고 실행 시 콘솔 창에 (lldb)라는 단어가 보이게 되는데, 이곳에 command를 입력하면됩니다.</li></ul><h2>Reference</h2><ul><li><a href="https://lldb.llvm.org/">lldb.llvm.org</a></li><li><a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html#//apple_ref/doc/uid/TP40012917-CH1-SW1">Apple - LLDB Quick Start Guide</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/MVVM</guid><title>MVVM 패턴</title><description>MVVM 패턴에 대한 이론</description><link>https://blog.jihoon.me/blog/MVVM</link><pubDate>Thu, 16 Feb 2023 01:15:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘은 iOS에서 가장 많이 사용하는 MVVM 패턴에 대해서 이론부분을 공부할 겁니다.</p><p>일단 시작하겠습니다!</p><hr><p>MVVM은 (Model - View - ViewModel)로 구성되어 있습니다. 각각의 역할을 알아보면</p><h3>Model</h3><ul><li>데이터 구조를 정의하고 ViewModel에 결과를 알려주는 역할을 합니다.</li></ul><h3>View</h3><ul><li>View는 사용자와의 상호작용을 통해 이벤트가 일어나면 ViewModel에게 알려줍니다.</li></ul><h3>ViewModel</h3><ul><li>ViewModel은 사용자의 상호작용을 view가 보내주면 이벤트에 맞는 처리를 하고 Model의 상태를 관리합니다.</li></ul><img width = 100% src = "https://miro.medium.com/max/1400/1*J7_36YMEO8pNAYGyR53hkA.png"></img><p><a href="https://www.google.com/url?sa=i&url=https%3A%2F%2Fmedium.com%2F%40json.ios.0802%2Fios-%25EB%2594%2594%25EC%259E%2590%25EC%259D%25B8%25ED%258C%25A8%25ED%2584%25B4-mvvm-ac676124c662&psig=AOvVaw2RgeE45Gij-UGJ4laxrAqU&ust=1676810923210000&source=images&cd=vfe&ved=0CBAQjRxqFwoTCOjnrM6Nn_0CFQAAAAAdAAAAABAI">Medium 블로그 중 MVVM ex</a></p><p>MVVM의 구조를 잘 보여주는 이미지 입니다.</p><p>기존의 View는 User Interface를 표시하기 위한 로직만 담당하고, 그 외에 메서드 호출 정도만 하는것이 이상적입니다.</p><p>ViewModel은 기존 UIKit을 import할 필요도 없이 데이터 update 및 View(UI) 요소를 업데이트 합니다.</p><p>Model은 데이터 구조를 갖습니다.</p><p>이런식으로 양방향 데이터 플로우 구조를 갖게 됩니다.</p><h3>장점</h3><ul><li>독립적인 테스트가 가능합니다.</li><li>단위 테스트에서 이점을 갖는다.</li><li>View와 Model의 독립성을 갖는다.</li></ul><h3>단점</h3><ul><li>설계가 어렵다.</li><li>데이터 바인딩이 필수적이다.</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Copy-On-Write</guid><title>Copy On Write</title><description>Copy On Write가 뭔지 알아봅시다.</description><link>https://blog.jihoon.me/blog/Copy-On-Write</link><pubDate>Wed, 15 Feb 2023 22:52:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘은 COW (Copy On Write) 에 대해서 배워 볼 것입니다. 개발할 때 꼭 알아야 하는 지식이기 때문에, 이번에 정리해보려고 합니다.</p><p>이제 시작하겠습니다!</p><hr><p>Swift 문서상에서는</p><blockquote><p>복사를 즉각적으로 하지 않고, collection들은 값들이 저장된 메모리를 원본 객체와 복사본들끼리 공유합니다.만약, collection의 복사본들중 하나가 변경되었다면, 수정되기 전에 복사됩니다.</p></blockquote><p>Swift에서 큰 값 타입의 데이터를 변수에 대입하거나 매개변수로 넘기게 되면 매우 비싼 복사 연산이 이루어집니다. 이러한 이슈를 최소화 하기 위해서 Swift 표준 라이브러리는 배열과 같은 몇몇 값 타입에 대해 (두 개 이상의 참조가 있고 변형에 의해서만 복사가 일어납니다.) 하나의 참조만 있으면 복사가 아니라 해당 참조 내에서 값 변경이 일어나는 매커니즘을 설계했습니다.</p><h3>Example</h3><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">func</span> address(o: <span class="type">UnsafeRawPointer</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="type">Int</span>(bitPattern: o)
}

<span class="keyword">var</span> value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]
<span class="keyword">var</span> copyValue = value

<span class="call">print</span>(<span class="string">"value:</span> \(<span class="call">address</span>(o: &amp;value))<span class="string">"</span>)
<span class="call">print</span>(<span class="string">"copyValue:</span> \(<span class="call">address</span>(o: &amp;copyValue))<span class="string">"</span>)
</code></pre><p>Value Type은 값 복사가 기본적으로 이루어집니다. 예시 코드의 결과 값을 봐봅시다.</p><pre><code>value: <span class="number">105553140417888</span>
copyValue: <span class="number">105553140417888</span>
<span class="type">Program</span> ended with exit code: <span class="number">0</span>
</code></pre><p>결국에 Swift 문서에서 처럼 Collection들은 실제로 값이 바로 복사되지 않고 같은 공간을 share합니다.</p><pre><code>copyValue.<span class="call">append</span>(<span class="number">4</span>)

<span class="call">print</span>(<span class="string">" --&gt; value:</span> \(<span class="call">address</span>(o: &amp;value))<span class="string">"</span>)
<span class="call">print</span>(<span class="string">" --&gt; copyValue:</span> \(<span class="call">address</span>(o: &amp;copyValue))<span class="string">"</span>)
</code></pre><p>변경이 일어났을때 바뀌게 되는지 확인해봅시다.</p><pre><code>value: <span class="number">105553140417888</span>
copyValue: <span class="number">105553150887520</span>
</code></pre><p>Collection Type은 값이 바로 복사가 되지 않고 공유하다가 값의 변경 직전에 Copy되어서 두개로 분리 되는 것을 확인 할 수 있었습니다.</p><hr><h2>OS에서 Copy On Write</h2><p>OS에서는 Copy On Write가 보통 fock()를 수행할 때 적용됩니다.</p><img width = 100% src = "https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_07_Page_C_Unmodified.jpg"></img><p>process1 과 proccess2로 나누어져 있지만 fork() 개념을 사용하게 되면 process2는 process1의 child process가 될 것 입니다. 이 두개는 같은 영역의 resource를 공유하고 있습니다.</p><img width = 100% src = "https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter9/9_08_Page_C_Modified.jpg"></img><p>parent나 child쪽이 resource를 수정하게 되면 사진처럼 바뀌게 됩니다. 즉 수정된 page C(Copy of page C)를 proccess1이 점유하고 이에 대한 포인터도 기존의 page C를 가리키던 포인터를 Copy of page C를 가리키게끔 변경하면 이로써 Copy On Write가 적용이 됩니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Yackety-Yak-iOS-4</guid><title>와글와글 제4회 발표 회고록</title><description>와글와글 iOS 제 4회 발표 회고</description><link>https://blog.jihoon.me/blog/Yackety-Yak-iOS-4</link><pubDate>Sat, 11 Feb 2023 05:25:00 +0000</pubDate><content:encoded><![CDATA[<iframe width="100%" height="380" src="https://www.youtube.com/embed/rDlcnt31re0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>이번 제 4회 와글와글 iOS에서 블로깅하는 방법에 대해서 발표를 했고, 이에 대한 회고 입니다. <br/><br/></p><h2>발표 준비</h2><p>발표 전 당시 저는 Publish에 관심도가 높아졌고, 다른 사람들에게 Publish 사용을 권하고 있었을 때 <br/> 리이오님이 감사하게도 발표를 제안을 주셔서 "Swift로 블로깅하기" 라는 주제로 발표를 하게 되었습니다. <br/></p><p>저의 첫 발표였기 때문에, 어떻게 준비해야하나 부터 고민하고, 발표를 어떻게 해야는지 고민을 했던 것 같습니다. <br/></p><p>미리 발표 자료를 만들기 위해서 Keynote내에서 어떤 목차로 진행 해야할지 부터 고민을 했습니다. <br/></p><pre><code>- 다른 <span class="type">Swift</span> 로 웹을 만드는 라이브러리와 비교
- <span class="type">Publish</span> 에 대한 소개 (소개 &amp; 특징)
- <span class="type">Publish</span> 설치
- <span class="type">Publish</span> 시작하기
- 어떤 결과물이 나올까
- 글 작성 방법
- 커스텀 하는 방법 
- <span class="type">Publish</span> 로 만들어진 <span class="type">Web</span> 들 예시
- 한계점
- 장점
- 느낀점
- 하고 싶은말
</code></pre><p>이런 목차로 진행하기로 정하고 발표 세부 내용을 작성하였습니다.<br/></p><img width="48.25%" src="https://user-images.githubusercontent.com/68891494/229304866-8fb2c86f-efec-4e13-a649-0c0a6ec6d44f.png"></img><img width="48%" src="https://user-images.githubusercontent.com/68891494/229304874-9710b33b-bea3-41f8-922b-d6573346f8d4.png"></img><p>이번 발표에서는 "왜 Publish인가?" 라는 것에 대한 저의 의견이 담는 것이 중요했습니다. <br/></p><p>또한 잘못된 내용을 전달하면 안되기 때문에, 반복적으로 검토하고 수정하기를 진행하였고, 발표 주제가 마이너한 라이브러리를 소개하기 때문에, Publish에 대한 대략적인 부분에 대한 설명부터 해야하기 때문에, 사람들에게 이해시키는 부분도 필요했고, 어떻게 사용할지에 대한 설명도 필요했습니다. <br/></p><p>이런 부분을 생각하다보니 Keynote의 내용이 너무 많아졌고, 발표 주제에 맞는 방향인 간단하게 소개하는 방식으로 바꾸기로 결정하였습니다. <br/></p><p>그리고 blog의 대부분 소스를 공개하지 않았기 때문에 너무 레퍼런스가 부족한 상황이였고, 처음 시작하는 사람들이 쉽게 이해할 수 있도록 레퍼런스 마련을 위해서 여러번의 고민 끝에 제가 직접 만든 블로그를 Public으로 공개하기로 결정하였습니다. <br/><br/></p><h2>발표 당일</h2><p>대망의 발표날이 찾아왔고, 저녁 7시 부터 발표를 시작할 준비를 하였습니다. 아침에 몇번 다시 내용을 확인하고, 발표에 대비를 하였으나, 점점 긴장을 하게되었습니다. 발표하기 10분 전에 미리 디스코드 방에 들어가서, 미리 대기를 하였습니다.</p><p><strong>발표 시작</strong></p><p>처음 진행을 할 때 8명으로 시작을 하였고, 추가적으로 3~4명 이상 진행 중에 들어오셨습니다. <br/> 발표 진행을 시작하자마자 문제가 발생했습니다.. 😓 <br/> 첫 발표인 이유도 있었지만, 발표를 많이 해보지 않았기 때문에 너무 긴장해버렸습니다.. <br/> 제가 너무 긴장해버린 나머지, 목소리도 잘 안나오고, 머리에서는 "아 망했다" 라는 생각이 들어서 추가적으로 더 긴장을 해버렸던 것 같습니다 ㅋㅋ.. <br/></p><p>정신 없이 발표가 진행되고, 하나의 걱정이 머리를 스쳐갔습니다. <br/></p><blockquote><p>"과연 발표 내용이 잘 전달 되었을까?"</p></blockquote><p>가장 발표에서 중요한 부분이지만, 다른 분들도 Publish를 한번 씩 사용해보겠다 라는 말을 듣고, 그래도 어느정도 발표에서 말하고 싶은 부분은 전달이 됬구나 라고 생각이 되서 다행이라고 생각이 들었습니다. <br/><br/></p><h2>발표가 끝나고</h2><p>제가 느끼기에는 아주 긴 발표시간이 지나가고, 개인적으로 긴장해버린 것 때문에 걱정을 많이 했고, 많은 아쉬움이 남았습니다. <br/> 그래도 첫 발표를 끝냈다는 생각에 저에게 어떤 부분이 부족하고, 나중의 발표에서 어떤 부분을 주의해야할 지도 알게되는 시간이였습니다. <br/></p><img width="50%" src="https://user-images.githubusercontent.com/68891494/229306762-6f3d2cfb-d7fc-47aa-9146-c5fea892c778.png"></img><p>리이오님이 좋은 자리를 마련해주셔서, 좋은 경험이 됬습니다. (감사합니다.. 🙏) <br/><br/></p><h2>느낀점</h2><p>이번에 발표를 해보고, 다른 곳에서도 발표를 해보고 싶다는 생각을 하게 되었습니다. <br/> 비록 이번에는 많은 부분이 부족했지만, 내가 알고 있는 것을 다른 사람과 공유하는 것에 대한 재미를 느끼게 되었고, 현재 발표에서 부족한 부분을 해결하기 위해서 더 많은 곳에서 발표하고 싶다는 생각을 하게 되었습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Using-RIBs-Part-2</guid><title>RIBs 사용해보기 Part 2</title><description>RIBs의 간단한 사용 방법에 대해서 알아봅시다.</description><link>https://blog.jihoon.me/blog/Using-RIBs-Part-2</link><pubDate>Fri, 4 Nov 2022 01:02:00 +0000</pubDate><content:encoded><![CDATA[<p>저번 포스트에서는 RIBs를 사용하기 위해서 세팅하는 법에 대해서 배웠습니다. 이번 포스트는 저번 글의 연장선입니다.</p><p>혹시 저번 글을 읽지 않으셨다면, <a href="https://blog.jihoon.me/posts/Using-RIBs-Part-1/">Using RIBs Part 1</a> 을 먼저 보고 오시는 것이 도움될 것입니다.</p><p>그럼 다시 시작해보겠습니다</p><hr><p>저희가 간단하게 구현할 앱입니다. 물론 오늘은 Onboarding이랑 Main만 연결할 것입니다.</p><img width = 80% src = "https://user-images.githubusercontent.com/68891494/201262846-f5854953-aa3f-454f-b885-0fbc05ec7cc7.png"></img><p>일단 Onboarding, Main RIB을 생성해줍니다.</p><img width = 50% src = "https://user-images.githubusercontent.com/68891494/201261727-94182b2a-e39b-4937-9955-10a6950dee41.png"></img><p>Root와 Main &amp; Onboarding을 연결해주기 위해서 RootBuilder에서 작업을 해줍니다.</p><pre><code><span class="keyword">func</span> build() -&gt; <span class="type">LaunchRouting</span> {
    <span class="keyword">let</span> component = <span class="type">RootComponent</span>(dependency: dependency)
    <span class="keyword">let</span> viewController = <span class="type">RootViewController</span>()
    <span class="keyword">let</span> interactor = <span class="type">RootInteractor</span>(presenter: viewController)
    <span class="keyword">let</span> onboardingBuilder = <span class="type">OnboardingBuilder</span>(dependency: component)
    <span class="keyword">let</span> mainBuilder = <span class="type">MainBuilder</span>(dependency: component)
    <span class="keyword">return</span> <span class="type">RootRouter</span>(interactor: interactor, viewController: viewController)
}
</code></pre><p>이렇게 하시면</p><img width="100%" src="https://user-images.githubusercontent.com/68891494/201265977-313c2925-3f3b-423f-bfae-d977929bb027.png"></img><p>이러한 에러가 발생합니다. 에러가 발생하는 이유는 Component에서 MainDependency와 OnboardingDependency를 상속하지 않았기 때문에 발생합니다.</p><p>RootBuilder 파일 안에 있는 RootComponent에 MainDependency와 OnboardingDependency를 상속해줍니다.</p><pre><code><span class="keyword">extension</span> <span class="type">RootComponent</span>: <span class="type">MainDependency</span>, <span class="type">OnboardingDependency</span> {}
</code></pre><p>이러면 에러가 사라질 것입니다!</p><p>이후 RootRouter에서 각각 RIB의 Buildable과 Routing을 생성합니다.</p><pre><code><span class="keyword">final class</span> RootRouter: <span class="type">LaunchRouter</span>&lt;<span class="type">RootInteractable</span>, <span class="type">RootViewControllable</span>&gt;, <span class="type">RootRouting</span> {
    <span class="comment">// MARK: - Onboarding</span>
    <span class="keyword">private let</span> onboardingBuilder: <span class="type">OnboardingBuildable</span>
    <span class="keyword">private var</span> onboardingRouter: <span class="type">OnboardingRouting</span>?
    <span class="comment">// MARK: - Main</span>
    <span class="keyword">private let</span> mainBuilder: <span class="type">MainBuildable</span>
    <span class="keyword">private var</span> mainRouter: <span class="type">MainRouting</span>?
    
    <span class="keyword">init</span>(
        onboardingBuilder: <span class="type">OnboardingBuildable</span>,
        mainBuilder: <span class="type">MainBuildable</span>,
        interactor: <span class="type">RootInteractable</span>,
        viewController: <span class="type">RootViewControllable</span>
    ) {
        <span class="keyword">self</span>.<span class="property">mainBuilder</span> = mainBuilder
        <span class="keyword">self</span>.<span class="property">onboardingBuilder</span> = onboardingBuilder
        <span class="keyword">super</span>.<span class="keyword">init</span>(interactor: interactor, viewController: viewController)
        interactor.<span class="property">router</span> = <span class="keyword">self</span>
    }
</code></pre><p>다시 Builder로 돌아와서</p><pre><code><span class="keyword">func</span> build() -&gt; <span class="type">LaunchRouting</span> {
    <span class="keyword">let</span> component = <span class="type">RootComponent</span>(dependency: dependency)
    <span class="keyword">let</span> viewController = <span class="type">RootViewController</span>()
    <span class="keyword">let</span> interactor = <span class="type">RootInteractor</span>(presenter: viewController)
    <span class="keyword">let</span> onboardingBuilder = <span class="type">OnboardingBuilder</span>(dependency: component)
    <span class="keyword">let</span> mainBuilder = <span class="type">MainBuilder</span>(dependency: component)
    <span class="keyword">return</span> <span class="type">RootRouter</span>(
        onboardingBuilder: onboardingBuilder,
        mainBuilder: mainBuilder,
        interactor: interactor,
        viewController: viewController
    )
}
</code></pre><p>RootRouter에 미리 만들어 놓은 Builder를 넘겨주시면 됩니다.</p><p>그다음.. (역시 RIBs는 세팅할게 많네요)</p><p>Root에서 Main, Onboarding 화면을 이동시켜보도록 하겠습니다.</p><p>Onboarding부터 attach 해보겠습니다.</p><pre><code><span class="keyword">protocol</span> RootInteractable: <span class="type">Interactable</span>, <span class="type">OnboardingListener</span>, <span class="type">MainListener</span> {
    <span class="keyword">var</span> router: <span class="type">RootRouting</span>? { <span class="keyword">get set</span> }
    <span class="keyword">var</span> listener: <span class="type">RootListener</span>? { <span class="keyword">get set</span> }
}
</code></pre><p>일단 시작하기 앞서, interactable 부분에 Listener를 상속 시킵니다.</p><p>그리고 Interactor에서 Routing에 무엇을 attach 할지, detach할지 적어줍니다.</p><pre><code><span class="keyword">protocol</span> RootRouting: <span class="type">ViewableRouting</span> {
    <span class="keyword">func</span> attachOnboarding()
    <span class="keyword">func</span> attachMain()
    <span class="keyword">func</span> detachOnboarding()
    <span class="keyword">func</span> detachMain()
}
</code></pre><p>그후 Attach 코드를 작성해주시면 됩니다.</p><pre><code><span class="keyword">func</span> attachOnboarding() {
    <span class="keyword">guard</span> onboardingRouting == <span class="keyword">nil else</span> { <span class="keyword">return</span> }
    <span class="keyword">let</span> router = onboardingBuilder.<span class="call">build</span>(withListener: interactor)
    <span class="keyword">let</span> vc = router.<span class="property">viewControllable</span>.<span class="property">uiviewController</span>
    vc.<span class="property">modalTransitionStyle</span> = .<span class="dotAccess">crossDissolve</span>
    vc.<span class="property">modalPresentationStyle</span> = .<span class="dotAccess">overFullScreen</span>
    viewControllable.<span class="property">uiviewController</span>.<span class="call">present</span>(vc, animated: <span class="keyword">true</span>)
    <span class="call">attachChild</span>(router)
    <span class="keyword">self</span>.<span class="property">onboardingRouting</span> = router
}
</code></pre><p>그리고 Attach가 되었으면 detach도 시켜줘야겠죠?</p><pre><code><span class="keyword">func</span> detachOnboarding() {
    <span class="keyword">guard let</span> router = onboardingRouting <span class="keyword">else</span> { <span class="keyword">return</span> }
    viewController.<span class="property">uiviewController</span>.<span class="call">dismiss</span>(animated: <span class="keyword">true</span>)
    <span class="keyword">self</span>.<span class="property">onboardingRouting</span> = <span class="keyword">nil</span>
    detachChild(router)
}
</code></pre><p>자 이제 Router 부분은 끝난것 같네요! 이제 정말 실행되는지 확인해보겠습니다!</p><p>Interactor로 가셔서</p><pre><code><span class="keyword">override func</span> didBecomeActive() {
      <span class="keyword">super</span>.<span class="call">didBecomeActive</span>()
      router?.<span class="call">attachOnboarding</span>()
}
</code></pre><p>이런식으로 테스트하겠습니다.</p><p>그냥 연결만 됬는지 확인하기 위해서 Onboarding에서 background 색상을 바꿔보겠습니다.</p><p>[실행화면]</p><img width = 30% src = "https://user-images.githubusercontent.com/68891494/201284305-3e750a12-3e62-4f19-8163-6fe4d3b3cedc.png">
</img><p>일단 연결이 됬습니다! 글이 길어지는 관계로 다음 파트에서 작성하도록 하겠습니다!</p><p><a href="https://github.com/Jihoonahn/Blog-Documment/tree/main/Architecture/RIBs/RIBs-2/ExRIBs">전체코드</a></p><p>[공지] RIBs example과 글 작성이 너무 오래 걸리는 관계로 RIBs 관련 글을 좀 미루려고 합니다 ㅎㅎ..</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Using-RIBs-Part-1</guid><title>RIBs 사용해보기 Part 1</title><description>RIBs의 간단한 사용 방법에 대해서 알아봅시다.</description><link>https://blog.jihoon.me/blog/Using-RIBs-Part-1</link><pubDate>Thu, 27 Oct 2022 14:05:00 +0000</pubDate><content:encoded><![CDATA[<p>저번 포스트에서는 RIBs에 대해서 이론을 공부했는데요! 이번 포스트에서는 RIBs의 실전으로 사용해보는 글입니다.</p><p>이전 포스트를 안읽으신 분은 <a href="https://blog.jihoon.me/posts/RIBs-Introduce">이전 글</a>을 읽어주세요!</p><hr><p>RIBs를 시작하기전에 <a href="https://github.com/uber/RIBs/tree/main/ios/tooling">RIBs Template</a>를 설치해주세요!</p><p>Project를 생성해주고, RIBs를 SwiftPackageManager 로 추가해주도록 하겠습니다!</p><img width="100%"  alt="my-option" src = "https://user-images.githubusercontent.com/68891494/198204193-93a77152-76e3-40ee-97ac-a2a0b0e57998.png"></img><p>RIBs를 추가하면 RxSwift도 같이 온다는 것을 볼 수 있습니다.</p><p>RIBs의 Package 파일을 보면 <a href="https://github.com/uber/RIBs/blob/main/Package.swift">RIBs Package</a></p><img width="70%"  alt="my-option" src = "https://user-images.githubusercontent.com/68891494/198204978-6334786b-34c6-4e45-a346-8b5b4b1f87db.png"></img><p>dependencies에서 RxSwift를 가져오는 것을 알 수 있습니다. 그리고 Target을 보면 RIBs가 RxSwift를 사용한다는 것을 확인할 수 있습니다.</p><p>RxSwift에 대한 글은 나중에 자세히 적도록 하겠습니다.</p><hr><p>이제 본론으로 와서 시작하도록 하겠습니다.</p><p>Root 파일부터 만들고 시작하겠습니다. 설치한 Template으로 Root를 생성해줍니다.</p><img width="50%" alt="my-option" src = "https://user-images.githubusercontent.com/68891494/198207168-2af3819a-d4aa-439f-a451-fa9752812598.png"></img><ul><li>저는 제가 직접 커스텀한 Template을 사용해서 조금 다를 수 있습니다.</li></ul><p>생성을 하셨다면 이렇게 파일 4개가 만들어 질겁니다.</p><img width=30% alt="my-option" src = "https://user-images.githubusercontent.com/68891494/198207667-88667f37-ee87-4aa0-a3d4-6e18b6b265d5.png"></img><p>Root 생성후에 화면을 띄우는 작업을 하겠습니다.</p><p>일단 AppComponentFile을 생성해주세요. 그후에 일단 처음에는 빈 component를 생성해주겠습니다.</p><pre><code><span class="keyword">import</span> RIBs

<span class="keyword">class</span> AppComponent : <span class="type">Component</span>&lt;<span class="type">EmptyDependency</span>&gt;, <span class="type">RootDependency</span>{
    <span class="keyword">init</span>(){
        <span class="keyword">super</span>.<span class="keyword">init</span>(dependency: <span class="type">EmptyComponent</span>())
    }
}
</code></pre><p>이후 설정을 위해서 SceneDelegate 파일로 이동해주세요! 그리고 willConnectTo 메서드를</p><pre><code><span class="keyword">private var</span> launchRouter: <span class="type">LaunchRouting</span>?

<span class="keyword">func</span> scene(<span class="keyword">_</span> scene: <span class="type">UIScene</span>, willConnectTo session: <span class="type">UISceneSession</span>, options connectionOptions: <span class="type">UIScene</span>.<span class="type">ConnectionOptions</span>) {
    <span class="keyword">if let</span> windowScene = scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span> {
          <span class="keyword">let</span> window = <span class="type">UIWindow</span>(windowScene: windowScene)
          <span class="keyword">self</span>.<span class="property">window</span> = window

          <span class="keyword">let</span> launchRouter = <span class="type">RootBuilder</span>(dependency: <span class="type">AppComponent</span>()).<span class="call">build</span>()
          <span class="keyword">self</span>.<span class="property">launchRouter</span> = launchRouter
          launchRouter.<span class="call">launch</span>(from: window)
      }
}
</code></pre><p>이렇게 바꾸시면 됩니다. 하지만 현재는 build()부분에서 에러가 발생할 것입니다. build() 에러를 해결하시려면 RootBuilder 파일로 가시면 됩니다.</p><p>처음 Builder에서는</p><pre><code><span class="keyword">func</span> build(withListener listener: <span class="type">RootListener</span>) -&gt; <span class="type">RootRouting</span> {
    <span class="keyword">let</span> component = <span class="type">RootComponent</span>(dependency: dependency)
    <span class="keyword">let</span> viewController = <span class="type">RootViewController</span>()
    <span class="keyword">let</span> interactor = <span class="type">RootInteractor</span>(presenter: viewController)
    interactor.<span class="property">listener</span> = listener
    <span class="keyword">return</span> <span class="type">RootRouter</span>(interactor: interactor, viewController: viewController)
}
</code></pre><p>이렇게 생성되어 있습니다. 하지만 저희는 파라미터를 주지 않을 것입니다.</p><p>해결하는 방법으로 Buildable을</p><pre><code><span class="keyword">protocol</span> RootBuildable: <span class="type">Buildable</span> {
    <span class="keyword">func</span> build() -&gt; <span class="type">LaunchRouting</span>
}
</code></pre><p>이렇게 바꿔주고, Build 메서드도</p><pre><code><span class="keyword">func</span> build() -&gt; <span class="type">LaunchRouting</span> {
    <span class="keyword">let</span> component = <span class="type">RootComponent</span>(dependency: dependency)
    <span class="keyword">let</span> viewController = <span class="type">RootViewController</span>()
    <span class="keyword">let</span> interactor = <span class="type">RootInteractor</span>(presenter: viewController)
    <span class="keyword">return</span> <span class="type">RootRouter</span>(interactor: interactor, viewController: viewController)
}
</code></pre><p>이렇게 바꿔주면 됩니다. 다시 빌드를 돌려보면 RootRouter 부분에 에러가 발생할 것입니다.</p><p>RootRouter파일로 이동후 RootRouter도 기존 ViewableRouter로 되어 있는 부분을</p><pre><code><span class="keyword">final class</span> RootRouter: <span class="type">ViewableRouter</span>&lt;<span class="type">RootInteractable</span>, <span class="type">RootViewControllable</span>&gt;, <span class="type">RootRouting</span> {
</code></pre><p>이렇게 바꿔주면 됩니다.</p><pre><code><span class="keyword">final class</span> RootRouter: <span class="type">LaunchRouter</span>&lt;<span class="type">RootInteractable</span>, <span class="type">RootViewControllable</span>&gt;, <span class="type">RootRouting</span> {
</code></pre><p>이렇게 되면 RIBs 초기 Root 세팅은 완료가 되었습니다!</p><p>RootViewController로 이동해서</p><pre><code><span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    view.<span class="property">backgroundColor</span> = <span class="type">UIColor</span>.<span class="property">white</span>
}    
</code></pre><p>간단하게 잘 마무리가됬는지 확인하기 위해서 색상을 바꿔보겠습니다.</p><img width="40%" src = "https://user-images.githubusercontent.com/68891494/198225700-53d5af41-9528-418e-b9c8-44c449fed831.png"></img><p>Root 세팅하는것부터 시간이 어마어마하게 드네요 이어서 작성하면 글이 계속 길어질 것 같아서 다음 글에서 이어서 적도록 하겠습니다!</p><h3>RIBs Part1 프로젝트 코드</h3><p>이곳에서 지금까지 작성된 코드를 확인할 수 있어요!</p><p><a href="https://github.com/Jihoonahn/Blog-Documment/tree/main/Architecture/RIBs/RIBs-1">전체 코드</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/RIBs-Introduce</guid><title>RIBs 소개</title><description>Uber에서 만든 RIBs라는 아키텍처에 대해서 공부해보자</description><link>https://blog.jihoon.me/blog/RIBs-Introduce</link><pubDate>Tue, 25 Oct 2022 14:09:00 +0000</pubDate><content:encoded><![CDATA[<p>Uber에서 만든 RIBs에 대해서 공부해 보겠습니다.</p><h3>What is RIBs?</h3><p>RIBs는 Uber에서 만든 cross-platform Mobile Architecture Framework 입니다.</p><p>공식 Github : <a href="https://github.com/uber/RIBs">RIBs</a></p><img width="100%"  alt="my-option" src="https://github.com/uber/ribs/raw/assets/documentation/ribs.png">
</img><p>RIBs는 Router, Interactor, Builder의 약자입니다.</p><p>하나의 RIB은 Router, Interactor, Builder를 필수적으로 구현해야하고 View와 Presenter는 필요에 따라 구성됩니다.</p><hr><h3>각각의 역할</h3><p><strong>Builder</strong></p><ul><li>RIBs 의 모든 구성요소를 생성하고 DI를 정의합니다. 즉 Router, Interactor, View, Component를 모두 생성합니다.</li></ul><p><strong>Component</strong></p><ul><li>부모 RIB의 Builder가 Component를 통해 자식 RIB의 Builder로 의존성 주입시켜줍니다.</li></ul><p><strong>Router</strong></p><ul><li>자식 RIB를 attach, detach하여 RIBs 논리적 트리 구조를 형성합니다.</li></ul><p><strong>Interactor</strong></p><ul><li>Business logic을 수행하며 Router로 Routing call 그리고 RIBs의 attach와 detach를 요청하거나, Presenter로 Data model를 전달합니다.</li></ul><p><strong>View</strong></p><ul><li>UI를 담당하는 로직입니다.</li><li>UI Event를 Presenter로 전달하거나 View model을 받아서 UI를 업데이트합니다.</li></ul><p><strong>Presenter</strong></p><ul><li>Interactor와 View간의 통신을 담당하며, Business model을 View model을 변환하는 역할로 상태를 가지고 있지 않은 클래스입니다. Presenter를 생략하는 경우 View model 변환의 책임은 View 또는 Interactor가 되어야 합니다.</li></ul><hr><p>필요에 따라 Presenter와 View가 구성된다의 의미는, VIPER 패턴과 달리 View가 포함되지 않고 비즈니스 로직으로만 구성된 Viewless RIB의 생성이 가능하다는 의미입니다.</p><h3>RIBs Tree</h3><img width="100%"  alt="my-option" src = "https://github.com/uber/ribs/raw/assets/documentation/state.gif"></img><p>RIBs는 논리적 트리구조를 형상하여, 부모 RIB와 자식 RIB 간의 통신을 합니다.</p><p>RIBs 간의 통신은 Interactor가 담당합니다.</p><p>부모와 자식간의 소통은 Observable Stream을 넘겨주어서 데이터를 전달합니다.</p><p>자식에서 부모로의 통신은 자식 Interactor에서 부모 Interactor을 Listener 인터페이스로 접근하게 됩니다.</p><h3>RIBs LifeCycle</h3><img width= "60%" alt="my-option" src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbpxXeS%2Fbtq2IkXxyk4%2Fpy5OqSBLtz0UUNbkdRAw3k%2Fimg.png"></img><ul><li>RIB의 Life cycle은 RIB이 Attach, Detach되는 상태가 존재합니다.</li></ul><img width= "60%" alt="my-option" src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbjTQ91%2Fbtq2HH6zXot%2FWLQuM9QXgRkO4nX8E7KAK0%2Fimg.png" ></img><ul><li>Router의 Animation설정이 필요하므로 Router에 Will, did에 관한 라이프사이클을 추가하면 사용하기 편리하게 만들 수 있습니다.</li></ul><h3>RIBs의 장단점</h3><h4>장점</h4><ul><li>“제대로 된 모듈화가 목적”이지만 VIPER는 그러지 않는 점이 존재</li><li>View의 Tree를 중심적으로 앱이 진행되는 단점, View에 의해 앱 상태가 동작되는 장점 → RIBs의 트리로 보완</li><li>View와 Business tree가 밀접하게 결합되어 있어, UI로직만 포함하거나 business 로직만 포함하는 노드를 구현하기 힘든 점<ul><li>RIBs는 Viewless RIB을 이용해서 Business Logic이 UI Logic에 종속되지 않게 만들 수 있습니다.</li></ul></li></ul><h4>단점</h4><ul><li>Boilerplate: 한 기능에 많은 클래스 수, 하나의 파일에 여러가지 클래스</li><li>Framework 의존성: RIBs라는 한 프레임워크에 프로젝트 전체가 종속</li></ul><h3>Template</h3><p><a href="https://github.com/uber/RIBs/tree/main/ios/tooling">공식 Template</a> | <a href="https://github.com/Jihoonahn/Xcode-Template/tree/main/ModernRIBs%20or%20RIBs">직접 개선한 RIBs Template</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/StaticFramework_And_DyamicFramework</guid><title>StaticFramework &amp; DynamicFramework</title><description>StaticFramework와 DynamicFramework의 차이점에 대해서 공부해봅시다.</description><link>https://blog.jihoon.me/blog/StaticFramework_And_DyamicFramework</link><pubDate>Mon, 24 Oct 2022 16:17:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘의 Post에서는 StaticFramework와 DynamicFramework 에 대해서 공부해 볼 것입니다.</p><p>Framework에 대해서 공부하던 중에, Static Framework와 Dynamic Framework는 완벽하게 숙지해야겠다 라는 생각이 들어서 바로 정리하게 되었습니다!</p><p>일단 시작해보겠습니다!</p><hr><h2>Framework?</h2><p>Framework는 Dynamic shared Library, nib File, Image File, localized strings, header files 및 reference 문서와 같이 공유 리소스를 패키지로 캡슐화 하는 계층 구조 파일 디렉토리를 이야기합니다. 그리고 Framework도 Bundle이며 NSBundle로 접근이 가능합니다. 또한 리소스 사본은 프로세스 수에 상관 없이 항상 물리적으로 메모리에 상주하며 리소스 공유로 풋 프린트를 줄이고 성능을 향상 시킵니다.</p><h2>Dynamic Framework</h2><img width = 100% src = "https://user-images.githubusercontent.com/68891494/202763635-ff77e71c-10d7-4225-b23a-09c0385a52de.png"></img><p>Xcode에서 Framework를 생성하면 Default로 DyamicFramework 로 생성이 됩니다. Dynamic Framework는 동시에 여러 프레임워크 또는 프로그램에서 동일한 코드사본을 공유하고 사용을 하므로, 메모리를 효율적으로 관리합니다. 동적으로 연결되어 있어, 전체 빌드를 하지 않아도 새로운 프레임워크가 사용이 가능합니다. Static Linker를 통해 <code></code>Dynamic Library Reference<code></code>가 어플리케이션에 들어가고 모듈 호출시 Stack에 있는 Library에 접근하여 사용합니다. 또한 여러 버전의 라이브러리가 존재할 수 있기 때문에 다음과 같은 symbolic links를 구성하기도 합니다.</p><img width = 60% src = "https://minsone.github.io/image/2019/10/3.png"></img><h2>Stactic Framework</h2><img width = 100% src = "https://user-images.githubusercontent.com/68891494/202765011-411d8cf4-3dce-45b7-adb4-82103c03337c.png">
</img><p>Static Framework는 Static Linker를 통해 Static Library 코드가 어플리케이션 코드내로 들어가 Heap 메모리를 상주합니다. 따라서 Static Library가 복사가 되므로, Static Framework를 여러 Framework에서 사용하면 코드 중복이 발생합니다.</p><p>Library는 Framework가 아니라 Static Library가 복사된 곳에 위치하므로, Bundle 위치는 Static Framework가 아닌 Static Library가 위치하는 곳에 있게 됩니다. 그렇기 때문에 번들에 접근할 때에는 스스로 접근하는 것보다 외부의 Bundle의 위치를 주입받는 것이 좋습니다.</p><h2>어떤 Mach-O Type을 선택해야 하나</h2><ul><li>Dynamic Framework: 리소스를 가지고 있거나 전체 소스를 제공하는 경우</li><li>Static Framework: SDK 형태로 배포하는 경우</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Mach-O</guid><title>Mach-O</title><description>Mach-O에 대해서 배워봅시다.</description><link>https://blog.jihoon.me/blog/Mach-O</link><pubDate>Sun, 23 Oct 2022 11:00:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘은 Mach-O에 대해서 배워볼 것입니다. 공부를 진행하는 도중 Mach-O에 대한 이야기가 많이 나오더라고요!</p><p>그래서 이번 기회에 깔끔하게 정리해보겠습니다!</p><p>일단 시작하겠습니다!</p><hr><h2>Mach-O</h2><p>Mach-O는 Apple OS에서 동작하는 컴파일된 프로그램에 대한 파일 포맷</p><ul><li>오브젝트 파일(.o)</li><li>동적 라이브러리(.dylib)</li><li>정적 라이브러리(.a)</li><li>번들 (.bundle)</li><li>커널 익스텐션(.kext)</li><li>그외 (Core Dump, Framework...등등)</li></ul><p>이런 파일 포맷들이 바로 Mach-O입니다..</p><p>그러면 Mach-O의 영역에 관해서 공부해봅시다.</p><h2>Mach-O 구조</h2><img width = 70%  src = "https://user-images.githubusercontent.com/68891494/202772719-547f0d38-83d5-4de0-aea8-1a6bb1133852.png"></img><p>애플 플랫폼에서 컴파일된 모든 것들은 다음과 같은 Mach-O 구조를 가집니다. (Header + Load Commands + Data)</p><hr><p>Header, Load Command, Segment Data 영역으로 나뉘어 있습니다.</p><p>하나씩 봐봅시다.</p><h2>Mach-O Header</h2><blockquote><p>해당 Program이 실행될 수 있는 CPU 아키텍처, Excutable의 타입, 헤더 다음에 오는 Load Command의 갯수.. 등의 정보가 담겨 있습니다.</p></blockquote><img width = 80% src = "https://user-images.githubusercontent.com/68891494/229299955-01c6f433-4849-4b5b-9e2e-cf733715128e.png"></img><p>예제를 봐봅시다.</p><p>DerivedData 폴더에 프로젝트에 대한 Executable 파일이 생성되어 있습니다.</p><p>Mach-O 파일을 읽을 수 있게 otool이라는 Command Tool을 애플에서 제공합니다.</p><p>otool 만 작성하면 어떤 옵션이 있는지 알 수 있습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/Swift-Compiler</guid><title>Swift Compiler</title><description>Swift는 어떻게 컴파일 될까요?</description><link>https://blog.jihoon.me/blog/Swift-Compiler</link><pubDate>Fri, 21 Oct 2022 00:49:00 +0000</pubDate><content:encoded><![CDATA[<p>오늘의 Post에서는 Swift Compiler 에 대해서 공부해 볼 것입니다.</p><p>일단 시작해보겠습니다!</p><hr><p>Swift 툴체인의 중심에는 Swift Compiler가 존재합니다.</p><p>Swift Compiler의 책임은 소스 코드를 실행할 수 있는 Object 코드로 변경시킵니다.</p><h3>Data Flow</h3><p>Swift Compiler는 LLVM이라는 Compiler의 기본구조에서 동작하며, 다음과 같은 data flow를 구성합니다.</p><p>Swift와 같은 high-level 언어를 machine code로 변환하는 과정은 Lowering이라는 실제 하드웨어에서 효과적으로 동작합니다.</p><p>둥근 코너의 사각형과 일반 사각형은 데이터의 Input 과 output을 나타내며, high level에서 부터 각각의 단계를 이해하는데 많은 도움을 줄 것입니다.</p><img width="50%"  alt="my-option" src="https://user-images.githubusercontent.com/68891494/196997871-4c97c0aa-c87a-475a-b79a-82b76d679bb7.png">
</img><ol><li><strong>Parse</strong>: Swift 소스는 먼저 token들로 변환되고, AST(abstract syntax tree)에 들어가게 됩니다. <br/> 각각의 노드로 표현되는 트리라고 생각할 수 있습니다. <br/> 각 노드들은 소스들의 위치 정보를 함께 가지고 있기 떄문에 에러를 찾았을 때 각 노드는 정확하게 어디에서 문제가 발생했는지 말해줍니다. <br/><br/></li></ol><ol start="2"><li><strong>Sematic Analysis(Sema)</strong>: 해당 단계에서 컴파일러는 AST를 사용하여 프로그램의 의미를 분석합니다. 해당 단계에서 type checking이 일어납니다. <br/> 마찬가지로 AST를 사용하기 때문에 에러가 발생한 위치를 정확하게 짚어낼 수 있습니다. <br/> type check 완료 후 AST는 type-checked AST 상태가 되며, 이를 SILGen 단계로 전달하게 됩니다. <br/><br/><ul></ul></li></ol><ol start="3"><li><strong>SILGen</strong>: 이 단계는 해당 단계를 가지지 않는 Clang 처럼 이전 컴파일러 파이프라인에서 벗어납니다. <br/> AST는 ASL(Swift Intermediate Language)로 lowered 됩니다. SIL은 basic block을 가지고 있는데, 이는 Swift Type, RC, Dispatch rules들과 computation을 가지고 있습니다. <br/> SIL은 raw와 canonical 두가지 특색을 가지고 있습니다. Canonical SIL은 raw SIL의 최소한의 최적화를 통한(모든 최적화를 진행하지 않아도) 결과입니다. <br/> SIL은 또한 소스의 위치 정보를 가지고 있기 때문에 의미있는 에러를 제공합니다. <br/><br/><ul></ul></li></ol><ol start="4"><li><strong>IRGen</strong>: 이 도구는 SIL을 LLVM의 Intermediate Representation으로 lower 시킵니다. 이 시점의 instructions는 Swift만의 특성이 아닙니다. (모든 LLVM 기반은 이 representation을 사용합니다.) <br/> IR은 꽤 추상적입니다. SIL 처럼 IR은 Static Single Assignment(SSA) 형태입니다. <br/> IR은 무제한의 레지스터를 가진 machine처럼 모델링하고, 최적화를 찾기 쉽게 만듭니다. <br/> 또한 Swift type과는 무관합니다. <br/><br/><ul></ul></li></ol><ol start="5"><li><strong>LLVM(Low Level Virtual Machine)</strong>: 최종 단계는 IR을 최적화 하고, 특정 플랫폼의 Machine의 명령어로 Lower를 진행합니다. <br/> 백엔드(machine 명령어를 방출하는것)에는 ARM, x86, Wasm 등이 포함됩니다. <br/> 위의 다이어그램은 Swift 컴파일러가 어떻게 object code를 생성하는지 보여줍니다. <br/> source code formatters, refactoring tools, documentation generators and syntax highlighters과 같은 도구들도 AST와 같은 중간 결과를 활용하여 최종 결과를 보다 견고하고 일관되게 만들 수 있습니다. <br/><br/></li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/What-is-SwiftUI</guid><title>SwiftUI 소개</title><description>선언형 UI로 생산성을 높여주는 SwiftUI에 대한 설명입니다.</description><link>https://blog.jihoon.me/blog/What-is-SwiftUI</link><pubDate>Thu, 20 Oct 2022 17:02:00 +0000</pubDate><content:encoded><![CDATA[<iframe width="100%" height= "400" src="https://www.youtube.com/embed/psL_5RIBqnY?start=7603" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p><strong>본 영상은 WWDC 19이며 SwiftUI 소개되는 부분에서 시작이됩니다.</strong></p><p>2019년 애플의 WWDC에서 처음 소개된 SwiftUI 는 모든 애플 운영체제용 앱을 개발하는데 있어서 완전히 새로운 방법을 제공합니다.</p><p>SwiftUI의 기본적인 목적은 앱 개발을 더 쉽고 폭발적인 생산성을 내면서 동시에 소프트웨어를 개발할 때 일반적으로 발생하는 버그들을 줄이는 것입니다. <br/> 또한 개발 과정에서도 앱의 라이브 프리뷰 기능을 이용하여 SwiftUI 프로젝트를 실시간으로 테스트할 수 있게 합니다. <br/></p><img width="100%" src="https://user-images.githubusercontent.com/68891494/229286766-44425ba2-bc64-4955-b106-99d99904313f.png"></img><p>위 이미지는 SwiftUI Project를 생성했을 때의 모습입니다. <br/><br/></p><h2>SwiftUI의 선언적 구문</h2><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Hello, world!"</span>)
                .<span class="call">frame</span>(maxWidth: .<span class="dotAccess">infinity</span>, maxHeight: .<span class="dotAccess">infinity</span>)
                .<span class="call">foregroundColor</span>(.<span class="dotAccess">white</span>)
        }
        .<span class="call">padding</span>()
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>UIKit과 인터페이스 빌더를 User Interface Layout을 설계하고 필요한 동작을 구현하는 것과는 완전히 다른 방법인 선언적 구문(declairactive syntax)이 SwiftUI에 도입되었습니다. <br/> 이 과정에서 기본적으로 레이아웃에 포함될 컴포넌트들을 선언하고, 그것들이 포함될 레이아웃 메니지 종류 (VStack, HStack, Form, List 등)를 명시하고, 속성을 설정하기 위해 수정자(modifier)를 사용합니다. <br/> 이렇게 선언하고 난 후 레이아웃의 위치와 constraint그리고 렌더링 방법에 대한 모든 복잡한 세부 사항은 SwiftUI가 자동으로 처리합니다. <br/> SwiftUI 선언은 계층적으로 구조화 되어 있습니다. 따라서 복잡한 뷰를 보다 쉽게 생성할 수 있습니다. <br/> <br/></p><h2>SwiftUI는 데이터 주도적</h2><p>SwiftUI 이전에는 앱 내에 있는 데이터의 현재 값을 검사하려면 그에 대한 코드를 앱에 포함 해야했습니다. <br/> 시간에 지남에 따라 데이터가 변한다면 사용자 인터페이스가 데이터의 최신 상태를 항상 반영하도록 하는 코드를 작성하거나, 데이터가 변경되었는지 주기적으로 검사하는 코드를 작성하는 것, 그리고 갱신 메뉴를 제공 해야했습니다. <br/> 이러한 데이터 소스를 앱의 여러 영역에서 사용할 경우 소스 코드의 복잡도가 증가합니다. <br/></p><blockquote><p><strong>SwiftUI는 앱의 데이터 모델과 사용자 인터페이스 컴포넌트, 그리고 기능을 제공하는 로직을 binding하는 여러방법으로 복잡도를 해결하게 됩니다.</strong> <br/></p></blockquote><p>데이터 주도로 구현하면 데이터 모델은 앱의 다른 부분에서 subscibe 할 수 데이터 변수는 publish 하게 됩니다. (publisher – subsciber) <br/> 이러한 방법을 통해 데이터가 변경되었다는 사실을 모든 구독자에게 자동으로 알릴 수 있습니다.<br/> 만약 사용자 인터페이스 컴포넌트와 데이터 모델 간에 바인딩이 된다면, <strong>추가적인 코드를 작성하지 않아도 모든 데이터의 변경 사항을 SwiftUI가 사용자 인터페이스에 자동으로 반영할 것</strong>입니다. <br/><br/></p><h2>UIKit VS SwiftUI</h2><img width="100%" src = "https://res.cloudinary.com/practicaldev/image/fetch/s--Ry1DiaP7--/c_imagga_scale,f_auto,fl_progressive,h_900,q_auto,w_1600/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85fmihrdl249k9cuid1i.png"></img><p><strong>UIKit</strong></p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
     
    <span class="keyword">private lazy var</span> button: <span class="type">UIButton</span> = {
        <span class="keyword">let</span> button = <span class="type">UIButton</span>()
        button.<span class="call">setTitle</span>(<span class="string">"Hello UIKit"</span>, for: .<span class="dotAccess">normal</span>)
        button.<span class="call">addTarget</span>(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(helloUIKitButtonAction), for: .<span class="dotAccess">touchUpInside</span>)
        <span class="keyword">return</span> button
    }()
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        view.<span class="property">backgroundColor</span> = .<span class="dotAccess">black</span>
        
        view.<span class="call">addSubview</span>(button)
        
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            button.<span class="property">centerXAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerXAnchor</span>),
            button.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerYAnchor</span>)
        ])
    }
    
    <span class="keyword">@objc private func</span> helloUIKitButtonAction() {
        <span class="call">printContent</span>(<span class="string">"Hello UIKit!"</span>)
    }
}
</code></pre><p><strong>SwiftUI</strong></p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Button</span>(<span class="string">"Hello SwiftUI"</span>) {
                <span class="call">print</span>(<span class="string">"Hello SwiftUI!"</span>)
            }
        }
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>같은 동작을 하는 뷰를 만들어 봤습니다. <br/></p><p>차이점이 보이시나요? UIKit(명령형)과 SwiftUI(선언형)을 비교해볼 때 <br/></p><p>UIKit에서는 Property를 선언 view에 추가하고, Layout에 제약사항을 준 후, action을 할 함수를 만들어서 button에 addTarget 해줍니다. <br/></p><p>하지만 SwiftUI에서는 그래로 원하는 위치에 Button을 추가하고 action을 추가하면 끝납니다. <br/></p><p>생산성 부분에서 어마어마하게 차이가 난다는 걸 볼 수 있습니다. <br/><br/></p><h2>UIKit과 SwiftUI를 함께 사용하는 방법</h2><p>사실 UIView와 SwiftUI를 함께 사용할 수 있는 방법은 다양하게 존재합니다. <br/></p><p>SwiftUI는 빠르고 효율적인 앱 개발 환경을 제공할 뿐만 아니라 코드를 크게 변경하지 않아도 다양한 애플 플랫폼에서 동일한 앱을 사용할 수 있게 합니다.<br/></p><p>하지만 지도 또는 웹 뷰를 통합해야 하는 특정 기능은 여전히 UIKit을 사용해야 하고, 매우 복잡한 UI 레이아웃을 설계하는 경우에 SwiftUI 레이아웃 컨테이너 뷰 사용이 만족스럽지 않을 수 있습니다. <br/></p><p>이런 상황에서는 인터페이스 빌더를 사용을 하는 방식으로 해결할 수도 있습니다. <br/><br/></p><h2>지금 SwiftUI는 어떨까?</h2><p>현재까지는 시기상조라는 말도 있고, 회사에서 도입 할 것이라는 말이 있습니다. <br/> 이 부분은 사람마다 의견이 다르기 때문에 정확한 대답은 어렵지만, 개인적으로 저는 자신이 처한 상황에서 직접 고려하여 결정하는 것이 좋다고 생각합니다. <br/></p><p>SwiftUI 최소 버전은 iOS 기준 13.0이지만, 제대로 사용하려면 15.0 이상이여야 하기 때문에, 이러한 부분은 좀 많이 아쉽긴 합니다. <br/></p><p>그리고 현재 SwiftUI는 버그도 있기도 하고, 아직 사용하기에는 불완전하다는 말에 동의는 합니다. <br/> 하지만 엄청난 생산성을 갖는다는것, 그리고 Apple이 추구하는 방향성의 UI Framework라는 것은 부정할 수 없기 때문에, iOS 개발자로 살면 언젠가는 사용해야하기 때문에 미리 공부해 보는 것도 좋다고 생각을 합니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/SwiftUI-Need-MVVM</guid><title>SwiftUI에 MVVM이 필요할까요?</title><description>요즘 이슈가 되고 있는 내용으로, 과연 SwiftUI에는 MVVM이 필요한지에 대한 저의 주관적인 생각을 담은 글입니다.</description><link>https://blog.jihoon.me/blog/SwiftUI-Need-MVVM</link><pubDate>Wed, 21 Sep 2022 12:00:00 +0000</pubDate><content:encoded><![CDATA[<p><a href="https://developer.apple.com/forums/thread/699003">Stop using MVVM for SwiftUI</a></p><p><a href="https://qiita.com/karamage/items/8a9c76caff187d3eb838">「SwiftUIでMVVMを採用するのは止めよう」と思い至った理由 - Qiita</a></p><p>요즘에 주의 깊게 보고 있는 issue 입니다.</p><p>위 글을 보면 SwiftUI에서 MVVM 사용을 멈추자는 의견을 제시하고 있습니다.</p><p><a href="https://medium.com/@karamage/stop-using-mvvm-with-swiftui-2c46eb2cc8dc">Stop using MVVM with SwiftUI</a></p><p>→ 제가 처음으로 본 사이트입니다.</p><p>“SwiftUI에서 MVVM 사용 중지”라는 강력한 주제로 저의 관심을 끌었습니다.</p><p>그 글은 꽤나 논리적인 글이라고 생각이 되었다. (진짜 많이 생각을 하게 만드는 글이라고 생각이 됩니다.)</p><p><a href="https://www.reddit.com/r/swift/comments/m60pv7/is_mvvm_an_antipattern_in_swiftui/">Is MVVM an anti-pattern in SwiftUI?</a></p><p>Reddit에서도 issue가 된 내용입니다.</p><h3>여기서부터는 저의 생각이 들어갔습니다.</h3><p>SwiftUI는? 선언형 뷰 프로그래밍 방식입니다.</p><p><strong>선언형 UI에서는 ViewModel은 필요할까</strong> 라는 주제의 여러 글들을 보고 따로 공부와 여러가지 생각을 했습니다.</p><p>옛날에는 “MVVM이 무조건 좋다” 라는 인식이 존재했습니다. 그런데 SwiftUI로 개발을 하면서 억지로 ViewModel을 만드는 상황이 발생하고 있습니다.</p><p>ViewModel은 비즈니스 로직을 분리하는 목적으로 사용할 수 있기 때문에 ViewModel이 완전히 나쁘다 라고 하기는 어려울것 같습니다. 하지만 SwiftUI에서 <strong>View가 자체적으로 Data Binding이 가능한 PropertyWrapper를 지원</strong>하기 때문에 아래와 같이 생각합니다.</p><h3>SwiftUI에서의 View는 이미 View+ViewModel 입니다.</h3><blockquote><p>ViewModel은 원래 상태를 View에 Binding하여 Reactive에 반영하기 위한 목적으로 도입되었지만, 선언적 UI에는 해당 기능이 포함되어 있으므로 ViewModel은 필요하지 않다고 생각합니다.</p></blockquote><h3>우리가 왜 MVVM이 무조건 좋다고 생각했을까요?</h3><p>이것은 기존 사용했던 UIKit을 보고 알 수 있었습니다.</p><p>위에서 대답한 내용이지만 더 설명을 붙이자면, UIKit에서는 View와 ViewModel의 데이터 바인딩을 Observable을 생성하거나 React 구현체인 <strong>RxSwift, Combine을 통해서 Reative하게 뷰에 값을 반영</strong>시켜주고 있었습니다.</p><p>기존 코드에서는 rx를 통해 데이터 바인딩을 해주는 코드를 사용했다. 흔하게 알고 있는 ViewModel을 통해서 뷰와 데이터 바인딩을 해주는 MVVM 구조입니다. ViewModel의 가장 중요한 역할은 데이터 바인딩입니다. 모델과 뷰 사이에 양방향 통신을 해주면서 바인딩을 시켜줍니다.</p><p><strong>하지만 SwiftUI에서는 View에서 다 해줄 수 있기 때문에 필요가 없다는 생각이 됩니다.</strong></p><h3>SwiftUI의 View에서 다 처리하라고?</h3><p>선언형 UI에서 ViewModel의 주요 기능인 데이터 바인딩이 필요없어진것입니다. 그래서 ViewModel이라고 표현하는 것이 어색하다고 생각이 됩니다. SwiftUI에서 MVVM 구조를 도입하는 것이 중간 계층의 레이어를 하나 더 두게 되는 복잡성이 생깁니다. View와 Model 사이에 없어도 되는 ViewModel이 들어가면서 굳이 양방향 데이터 플로우 구조가 되게 해야할까요?</p><p>요즘 핫하고 장점이 많은 단방향 아키텍처의 구조와는 거리가 멉니다.</p><p><strong>애플이 SwiftUI의 섹션에서 State와 Data Flow를 설명하면서도 보여준 예시가 있는데 이 또한 단방향 데이터 플로우를 권장하고 소개</strong>합니다.</p><img width="100%" alt="my-option" src="https://user-images.githubusercontent.com/73165292/196845240-6b0ed156-f79f-4d70-9b13-fcabe343725b.png">
</img><p>상태 즉 State를 관리해줌으로 View를 나타내주면서 모든 흐름이 단방향 구조가 됩니다.</p><p>즉 상태 관리 기반의 단방향 구조라고 볼 수 있다.</p><p><strong>선언형 UI를 사용하는 환경에서는 단방향 데이터 플로우 구조를 지향합니다.</strong></p><p>현재 많은 개발자들이 아키텍처 패턴으로 MVVM을 사용합니다. 많은 자료들이 SwiftUI + MVVM을 사용하는 방법에 대해서 설명을 하고 있습니다. 하지만 저는 이러한 행위는 불필요하다고 생각합니다.</p><p><strong>SwiftUI에서 MVVM을 사용하는 것은 MVVM + MVVM 즉 이중 구현이 된다고 생각이 됩니다.</strong></p><p>저는 이러한 동작이 정말 불필요하다고 생각을 합니다.</p><p>요즘 React나 Vue 또는 Flutter에서도 MVVM이 사용되고 있지 않습니다.</p><p>공통점으로 선언형 UI를 사용한다는 것을 알수 있습니다.</p><h3>그럼 뭘 사용하라는 건가</h3><p>ViewModel을 안사용하면 로직과 UI 분리는 어디서 담당해야할까?</p><p><a href="https://www.youtube.com/watch?v=mTv96vqTDhc&t=756s">Realm</a>에서는 MVI 접근 방식을 지향한다고 합니다.</p><p>원본에서 작성자는 두가지 방법을 제시합니다.</p><ol><li>Model에서 이를 구현한다.</li><li>Flux 개념의 Store로 분리한다.</li></ol><p>1번도 가능은 하나 모델에 비즈니스 로직을 넣으면 단방향 데이터 플로우를 해치게 된다고 생각합니다.</p><p>그래서 2번째 방법인 Flux적인 Store의 개념으로 분리해 거기서 View를 나타낼 상태 즉 State를 관리해주는 것이 적절하다고 생각합니다.</p><h3>글 정리</h3><p>이 글을 적으면서도 참으로 많은 생각을 하게 됩니다.</p><p><strong>선언형 UI를 사용하는 환경에서는 MVI, Flux 정도가 잘 어울린다고 생각이 됩니다.</strong></p><p>MVI는 단방향 아키텍처이며, Flux는 Composit한 조합을 통해 상태 관리를 하는 마찬가지로 단방향 아키텍처입니다.</p><p>우리가 필요한 것들은</p><ul><li>View와 비즈니스 로직 분리</li><li>단방향의 데이터 플로우</li><li>각 View를 통해 나타낼 Component의 설계 및 조합</li><li>Component들의 상태 관리 및 연결</li></ul><p>MVVM 아키텍처는 이런 문제를 해결할 수 없다고 생각합니다.</p><p>저는 이 논쟁에 대해 저의 생각을 답글에 달았습니다.</p><img width="100%" alt="my-option" src="https://user-images.githubusercontent.com/73165292/196845524-2621e870-0fc8-4caf-b636-34aa2a452be9.png">
</img>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/What-is-Swift</guid><title>Swift란?</title><description>Swift 언어에 대한 소개입니다.</description><link>https://blog.jihoon.me/blog/What-is-Swift</link><pubDate>Sun, 11 Apr 2021 07:02:00 +0000</pubDate><content:encoded><![CDATA[<p><a href="https://developer.apple.com/swift/">Apple 공식 Swift</a></p><p>스위프트는 iOS, macOS, watchOS, tvOS를 개발하기 위해 애플에서 제공하는 프로그래밍 언어 입니다.</p><h3>Swift의 특징</h3><p>애플이 최초에 스위프트를 발표했을 때 스위프트 언어의 특성을 Safe, Modern, Powerful 이라고 발표했습니다. 그러나 오픈소스로 전환되면서 특징을 Safe, Fast, Expressive로 변경하여 발표했습니다. 더불어 애플은 ‘스위프트는 보다 직관적이고 배우기 쉬운 언어’라고 스위프트를 소개했습니다. 먼저 애플이 발표한 스위프트의 언어적 특성을 항목별로 정리해 보았습니다.</p><h3>Safe</h3><p>스위프트는 안전한 프로그래밍을 지향합니다.</p><p>소프트웨어가 배포되기 전에, 즉 프로그래밍을 하는 중에 프로그래머가 저지를 수 있는 실수를 엄격한 문법을 통하여 미연에 방지하고자 노력했습니다. 때론 너무 강제적이라고 느껴질 수 있지만 문법적 제재는 실수를 줄이는 데 도움이 됩니다. 버그를 수정하거나 실수를 찾아내는 시간을 절약할 수 있습니다.</p><p>옵셔널이라는 기능을 비롯하여 guard 구문, 오류처리, 강력한 타입통제 등을 통해 스위프트는 안전한 프로그래밍을 구현하고 있습니다.</p><h3>Fast</h3><p>스위프트는 C 언어를 기반으로 한 C, C++, Objective-C와 같은 프로그래밍 언어를 대체하려는 목적으로 만들어졌습니다. 아직은 부분적으로 미흡하지만 성능 또한 C 언어 수준을 목표로 개발되었습니다. 그래서 스위프트는 성능을 예측할 수 있고 일정한 수준으로 유지할 수 있는 부분에 초점을 맞춰 개발되었습니다.</p><p>실행속도의 최적화 뿐만 아니라 컴파일러의 지속된 개량을 통해 더 빠른 컴파일 성능을 구현해 나가고 있습니다.</p><h3>Expressive</h3><p>스위프트는 여러 가지 프로그래밍 패러다임을 채용한 다중 패러다임 프로그래밍 언어입니다. 크게 보면 스위프트는 명령형 프로그래밍 패러다임, 객체지향 프로그래밍 패러다임, 함수형 프로그래밍 패러다임, 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 정확하게는 명령형과 객체지향 프로그래밍 패러다임을 기반으로 한 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 결과적으로 스위프트에서 가장 강조하는 부분은 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임입니다. 기존의 C 언어는 명령형 혹은 절자적 프로그래밍 패러다임을 채용했으며, C++, Java 등의 언어는 명령형 프로그래밍 패러다임과 객체지향 프로그래밍 패러다임을 동시에 채용한 다중 프로그래밍 패러다임 언어입니다.</p><p>최신 업데이트는 <a href="https://github.com/apple/swift/releases/tag/swift-5.7-RELEASE">5.7</a>입니다.</p><h2>Xcode Start</h2><p>Xcode는 iOS App 개발을 위한 IDE(통합 개발 환경, Integrated Development Environment) 입니다. iOS 뿐만 아니라 macOS, iPadOS, tvOS, watchOS... 등등 다양판 플랫폼을 제공할 수 있다.</p><p><a href="https://apps.apple.com/kr/app/xcode/id497799835?mt=12">AppStore</a></p><p>또는</p><p>명령어를 통해서 설치할 수 있습니다.</p><pre><code>xcode-select --install
</code></pre>]]></content:encoded></item></channel></rss>